{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ty","text":"<p>An extremely fast Python type checker, written in Rust.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Try out the online playground, or run ty with uvx to get started quickly:</p> <pre><code>uvx ty\n</code></pre> <p>For other ways to install ty, see the installation documentation.</p> <p>If you do not provide a subcommand, ty will list available commands \u2014 for detailed information about command-line options, see the CLI reference.</p> <p>Use the <code>check</code> command to run the type checker:</p> <pre><code>uvx ty check\n</code></pre> <p>ty will run on all Python files in the working directory and or subdirectories. If used from a project, ty will run on all Python files in the project (starting in the directory with the <code>pyproject.toml</code>)</p> <p>You can also provide specific paths to check:</p> <pre><code>uvx ty check example.py\n</code></pre> <p>When type checking, ty will find installed packages in the active virtual environment (via <code>VIRTUAL_ENV</code>) or discover a virtual environment named <code>.venv</code> in the project root or working directory. It will not find packages in non-virtual environments without specifying the target path with <code>--python</code>. See the module discovery documentation for details.</p>"},{"location":"#usage","title":"Usage","text":"<p>Run <code>ty check</code>, in your project's top-level directory, to check the project for type errors using ty's default configuration.</p> <p>If this provokes a cascade of errors, and you are using the standard library <code>venv</code> module to provide your virtual environment, add the venv directory to your <code>.gitignore</code> or <code>.ignore</code> file and then retry.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#configuration-files","title":"Configuration files","text":"<p>ty supports persistent configuration files at both the project- and user-level.</p> <p>Specifically, ty will search for a <code>pyproject.toml</code> or <code>ty.toml</code> file in the current directory, or in the nearest parent directory.</p> <p>If a <code>pyproject.toml</code> file is found, ty will read configuration from the <code>[tool.ty]</code> table. For example, to ignore the <code>index-out-of-bounds</code> rule, add the following to a <code>pyproject.toml</code>:</p> <p><code>pyproject.toml</code>:</p> <pre><code>[tool.ty.rules]\nindex-out-of-bounds = \"ignore\"\n</code></pre> <p>(If there is no <code>tool.ty</code> table, the <code>pyproject.toml</code> file will be ignored, and ty will continue searching in the directory hierarchy.)</p> <p>ty will also search for <code>ty.toml</code> files, which follow an identical structure, but omit the <code>[tool.ty]</code> prefix. For example:</p> <p><code>ty.toml</code>:</p> <pre><code>[rules]\nindex-out-of-bounds = \"ignore\"\n</code></pre> <p>Note</p> <p><code>ty.toml</code> files take precedence over <code>pyproject.toml</code> files, so if both <code>ty.toml</code> and <code>pyproject.toml</code> files are present in a directory, configuration will be read from <code>ty.toml</code>, and the <code>[tool.ty]</code> section in the accompanying <code>pyproject.toml</code> will be ignored.</p> <p>ty will also discover user-level configuration at <code>~/.config/ty/ty.toml</code> (or <code>$XDG_CONFIG_HOME/ty/ty.toml</code>) on macOS and Linux, or <code>%APPDATA%\\ty\\ty.toml</code> on Windows. User-level configuration must use the <code>ty.toml</code> format, rather than the <code>pyproject.toml</code> format, as a <code>pyproject.toml</code> is intended to define a Python project.</p> <p>If project- and user-level configuration files are found, the settings will be merged, with project-level configuration taking precedence over the user-level configuration.</p> <p>For example, if a string, number, or boolean is present in both the project- and user-level configuration tables, the project-level value will be used, and the user-level value will be ignored. If an array is present in both tables, the arrays will be merged, with the project-level settings appearing later in the merged array.</p> <p>Settings provided via command line take precedence over persistent configuration.</p> <p>See the configuration reference for an enumeration of the available settings.</p>"},{"location":"editors/","title":"Editor integration","text":"<p>ty can be integrated with various editors to provide a seamless development experience.</p>"},{"location":"editors/#vs-code","title":"VS Code","text":"<p>The Astral team maintains an official VS Code extension.</p> <p>Install the ty extension from the VS Code Marketplace.</p> <p>See the extension's README for more details on usage.</p>"},{"location":"editors/#neovim","title":"Neovim","text":"<p>For Neovim 0.10 or earlier (with <code>nvim-lspconfig</code>):</p> <pre><code>require('lspconfig').ty.setup({\ninit_options = {\nsettings = {\n-- ty language server settings go here\n}\n}\n})\n</code></pre> <p>For Neovim 0.11+ (with <code>vim.lsp.config</code>):</p> <pre><code>-- Optional: Only required if you need to update the language server settings\nvim.lsp.config('ty', {\ninit_options = {\nsettings = {\n-- ty language server settings go here\n}\n}\n})\n-- Required: Enable the language server\nvim.lsp.enable('ty')\n</code></pre>"},{"location":"editors/#other-editors","title":"Other editors","text":"<p>ty can be used with any editor that supports the language server protocol.</p> <p>To start the language server, use the <code>server</code> subcommand:</p> <pre><code>ty server\n</code></pre> <p>Refer to your editor's documentation to learn how to connect to an LSP server.</p> <p>See the editor settings for more details on configuring the language server.</p>"},{"location":"exclusions/","title":"Excluding files","text":"<p>ty automatically discovers all Python files in your project. You can customize where ty searches by using the <code>src.include</code> and <code>src.exclude</code> settings.</p> <p>For example, with the following configuration, ty checks all Python files in the <code>src</code> and <code>tests</code> directories except those in the <code>src/generated</code> directory:</p> <pre><code>[tool.ty.src]\ninclude = [\"src\", \"tests\"]\nexclude = [\"src/generated\"]\n</code></pre> <p>By default, ty excludes a variety of commonly ignored directories. If you want to include one of these directories, you can do so by adding a negative <code>exclude</code>:</p> <pre><code>[tool.ty.src]\n# Remove `build` from the excluded directories.\nexclude = [\"!**/build/\"]\n</code></pre> <p>By default, ty ignores files listed in an <code>.ignore</code> or <code>.gitignore</code> file. To disable this functionality, set <code>respect-ignore-files</code> to <code>false</code>.</p> <p>You may also explicitly pass the paths that ty should check, e.g.:</p> <pre><code>ty check src scripts/benchmark.py\n</code></pre> <p>Paths that are passed as positional arguments to <code>ty check</code> are included even if they would otherwise be ignored through <code>exclude</code> filters or an ignore-file.</p>"},{"location":"exclusions/#include-and-exclude-syntax","title":"Include and exclude syntax","text":"<p>Both <code>include</code> and <code>exclude</code> support gitignore like glob patterns:</p> <ul> <li><code>src/</code> matches a directory (including its contents) named <code>src</code>.</li> <li><code>src</code> matches a file or directory (including its contents) named <code>src</code>.</li> <li><code>*</code> matches any (possibly empty) sequence of characters (except <code>/</code>).</li> <li><code>**</code> matches zero or more path components.     This sequence must form a single path component, so both <code>./**a</code> and <code>./b**/</code> are invalid and will result in an error.     A sequence of more than two consecutive <code>*</code> characters is also invalid.</li> <li><code>?</code> matches any single character except <code>/</code></li> <li><code>[abc]</code> matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode,     so e.g. <code>[0-9]</code> specifies any character between <code>0</code> and <code>9</code> inclusive. An unclosed bracket is invalid.</li> </ul> <p>All patterns are anchored: The pattern <code>src</code> only includes <code>&lt;project_root&gt;/src</code> but not something like <code>&lt;project_root&gt;/test/src</code>. To include any directory named <code>src</code>, use the prefix match <code>**/src</code>. The same applies for exclude patterns where <code>src</code> only excludes <code>&lt;project_root&gt;/src</code> but not something like <code>&lt;project_root&gt;/test/src</code>.</p> <p>Note</p> <p>A prefix include pattern like <code>**/src</code> can notably slow down the Python file discovery.</p> <p>All fields accepting patterns use the reduced portable glob syntax from PEP 639, with the addition that characters can be escaped with a backslash.</p>"},{"location":"installation/","title":"Installing ty","text":""},{"location":"installation/#adding-ty-to-your-project","title":"Adding ty to your project","text":"<p>Use uv (or your project manager of choice) to add ty as a development dependency:</p> <pre><code>uv add --dev ty\n</code></pre> <p>Adding ty as a dependency ensures that all developers on the project are using the same version of ty.</p> <p>Then, use <code>uv run</code> to invoke ty:</p> <pre><code>uv run ty\n</code></pre>"},{"location":"installation/#installing-globally","title":"Installing globally","text":"<p>Install ty globally with uv:</p> <pre><code>uv tool install ty@latest\n</code></pre> <p>Or, pipx:</p> <pre><code>pipx install ty\n</code></pre>"},{"location":"installation/#installing-with-pip","title":"Installing with pip","text":"<p>Install ty into your current Python environment with pip:</p> <pre><code>pip install ty\n</code></pre>"},{"location":"modules/","title":"Module discovery","text":""},{"location":"modules/#first-party-modules","title":"First-party modules","text":"<p>First-party modules are Python files that are part of your project source code.</p> <p>By default, ty searches for first-party modules in the project's root directory or the <code>src</code> directory, if present.</p> <p>If your project uses a different layout, configure the project's <code>environment.root</code> in your <code>pyproject.toml</code> or <code>ty.toml</code>. For example, if your project's code is in an <code>app/</code> directory:</p> <pre><code>example-pkg\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 app\n    \u2514\u2500\u2500 example_pkg\n        \u2514\u2500\u2500 __init__.py\n</code></pre> <p>then set <code>environment.root</code> in your <code>pyproject.toml</code> to <code>[\"./app\"]</code>:</p> <pre><code>[tool.ty.environment]\nroot = [\"./app\"]\n</code></pre>"},{"location":"modules/#third-party-modules","title":"Third-party modules","text":"<p>Third-party modules are Python packages that are not part of your project or the standard library. These are usually declared as dependencies in a <code>pyproject.toml</code> or <code>requirements.txt</code> file and installed using a package manager like uv or pip. Examples of popular third-party modules are <code>requests</code>, <code>numpy</code> and <code>django</code>.</p> <p>ty searches for third-party modules in the configured Python environment.</p>"},{"location":"modules/#python-environment","title":"Python environment","text":"<p>The Python environment is used for discovery of third-party modules.</p> <p>By default, ty will attempt to discover a virtual environment.</p> <p>First, ty checks for an active virtual environment using the <code>VIRTUAL_ENV</code> environment variable. If not set, ty will search for a <code>.venv</code> directory in the project root or working directory. ty only supports discovery of virtual environments at this time.</p> <p>Note</p> <p>When using project management tools, such as uv or Poetry, the <code>run</code> command usually automatically activates the virtual environment and will be detected by ty.</p> <p>The Python environment may be explicitly configured using the <code>environment.python</code> setting or <code>--python</code> flag.</p> <p>When setting the environment explicitly, non-virtual environments can be provided.</p>"},{"location":"python-version/","title":"Python version","text":"<p>The Python version affects allowed syntax, type definitions of the standard library, and type definitions of first- and third-party modules that are conditional on the Python version.</p> <p>For example, Python 3.10 introduced support for <code>match</code> statements and added the <code>sys.stdlib_module_names</code> symbol to the standard library. Syntactic features always need to be available in the lowest supported Python version, but symbols may be used in a <code>sys.version_info</code> conditional branch:</p> <pre><code>import sys\n# `invalid-syntax` error if `python-version` is set to 3.9 or lower:\nmatch \"echo hello\".split():\ncase [\"echo\", message]:\nprint(message)\ncase _:\nprint(\"unknown command\")\n# `unresolved-attribute` error if `python-version` is set to 3.9 or lower:\nprint(sys.stdlib_module_names)\nif sys.version_info &gt;= (3, 10):\n# ok, because the usage is guarded by a version check:\nprint(sys.stdlib_module_names)\n</code></pre> <p>By default, the lower bound of the project's <code>requires-python</code> field (from the <code>pyproject.toml</code>) is used as the target Python version, ensuring that features and symbols only available in newer Python versions are not used.</p> <p>If the <code>requires-python</code> field is not available but a virtual environment has been configured or detected, ty will try to infer the Python version being used from the virtual environment's metadata.</p> <p>If no virtual environment is present or inferring the Python version from the metadata fails, ty will fall back to the latest stable Python version supported by ty (currently 3.13).</p> <p>The Python version may also be explicitly specified using the <code>python-version</code> setting or the <code>--python-version</code> flag.</p>"},{"location":"rules/","title":"Rules","text":"<p>Rules are individual checks that ty performs to detect common issues in your code, such as incompatible assignments, missing imports, or invalid type annotations. Each rule focuses on a specific pattern and can be turned on or off depending on your project\u2019s needs.</p> <p>Tip</p> <p>See rules for an enumeration of all supported rules.</p>"},{"location":"rules/#rule-levels","title":"Rule levels","text":"<p>Each rule has a configurable level:</p> <ul> <li><code>error</code>: violations are reported as errors and ty exits with an exit code of 1 if there's any.</li> <li><code>warn</code>: violations are reported as warnings. Depending on your configuration, ty exits with an exit code of 0 if there are only warning violations (default) or 1 when using <code>--error-on-warning</code>.</li> <li><code>ignore</code>: the rule is turned off</li> </ul> <p>You can configure the level for each rule on the command line using the <code>--warn</code>, <code>--error</code>, and <code>--ignore</code> flags. For example:</p> <pre><code>ty check \\\n--warn unused-ignore-comment \\        # Make `unused-ignore-comment` a warning\n--ignore redundant-cast \\             # Disable `redundant-cast`\n--error possibly-unbound-attribute \\  # Error on `possibly-unbound-attribute`\n--error possibly-unbound-import       # Error on `possibly-unbound-import`\n</code></pre> <p>The options can be repeated. Subsequent options override earlier options.</p> <p>Rule levels can also be changed in the <code>rules</code> section of a configuration file.</p> <p>For example, the following is equivalent to the command above:</p> <pre><code>[tool.ty.rules]\nunused-ignore-comment = \"warn\"\nredundant-cast = \"ignore\"\npossibly-unbound-attribute = \"error\"\npossibly-unbound-import = \"error\"\n</code></pre>"},{"location":"suppression/","title":"Suppression","text":"<p>Rules can also be ignored in specific locations in your code (instead of disabling the rule entirely) to silence false positives or permissible violations.</p> <p>Note</p> <p>To disable a rule entirely, set it to the <code>ignore</code> level as described in rule levels.</p>"},{"location":"suppression/#ty-suppression-comments","title":"ty suppression comments","text":"<p>To suppress a rule violation inline add a <code># ty: ignore[&lt;rule&gt;]</code> comment at the end of the line:</p> <pre><code>a = 10 + \"test\"  # ty: ignore[unsupported-operator]\n</code></pre> <p>Rule violations spanning multiple lines can be suppressed by adding the comment at the end of the violation's first or last line:</p> <pre><code>def add_three(a: int, b: int, c: int): ...\n# on the first line\nadd_three(  # ty: ignore[missing-argument]\n3,\n2\n)\n# or, on the last line\nadd_three(\n3,\n2\n)  # ty: ignore[missing-argument]\n</code></pre> <p>To suppress multiple violations on a single line, enumerate each rule separated by a comma:</p> <pre><code>add_three(\"one\", 5)  # ty: ignore[missing-argument, invalid-argument-type]\n</code></pre> <p>Note</p> <p>Enumerating rule names (e.g., <code>[rule1, rule2]</code>) is optional. However, we strongly recommend including suppressing specific rules to avoid accidental suppression of other errors.</p>"},{"location":"suppression/#standard-suppression-comments","title":"Standard suppression comments","text":"<p>ty supports the standard <code>type:ignore</code> comment format introduced by PEP 484.</p> <p>ty handles these similarly to <code>ty: ignore</code> comments, but suppresses all violations on that line, even when <code>type: ignore[code]</code> is used.</p> <pre><code># Ignore all typing errors on the next line\nadd_three(\"one\", 5)  # type: ignore\n</code></pre>"},{"location":"suppression/#unused-suppression-comments","title":"Unused suppression comments","text":"<p>If the <code>unused-ignore-comment</code> rule is enabled, ty will report unused <code>ty: ignore</code> and <code>type: ignore</code> comments.</p> <p><code>unused-ignore-comment</code> violations can only be suppressed using <code># ty: ignore[unused-ignore-comment]</code>. They cannot be suppressed using <code># ty: ignore</code> without a rule code or <code># type: ignore</code>.</p>"},{"location":"suppression/#no_type_check-directive","title":"<code>@no_type_check</code> directive","text":"<p>ty supports the <code>@no_type_check</code> decorator to suppress all violations inside a function.</p> <pre><code>from typing import no_type_check\ndef add_three(a: int, b: int, c: int):\na + b + c\n@no_type_check\ndef main():\nadd_three(3, 4)\n</code></pre> <p>Decorating a class with <code>@no_type_check</code> isn't supported.</p>"},{"location":"reference/cli/","title":"CLI","text":""},{"location":"reference/cli/#cli-reference","title":"CLI Reference","text":""},{"location":"reference/cli/#ty","title":"ty","text":"<p>An extremely fast Python type checker.</p> Usage <pre><code>ty &lt;COMMAND&gt;\n</code></pre> Commands <code>ty check</code><p>Check a project for type errors</p> <code>ty server</code><p>Start the language server</p> <code>ty version</code><p>Display ty's version</p> <code>ty help</code><p>Print this message or the help of the given subcommand(s)</p>"},{"location":"reference/cli/#ty-check","title":"ty check","text":"<p>Check a project for type errors</p> Usage <pre><code>ty check [OPTIONS] [PATH]...\n</code></pre> Arguments <code>PATHS</code><p>List of files or directories to check [default: the project root]</p> Options <code>--color</code> when<p>Control when colored output is used</p> <p>Possible values:</p> <ul> <li><code>auto</code>:  Display colors if the output goes to an interactive terminal</li> <li><code>always</code>:  Always display colors</li> <li><code>never</code>:  Never display colors</li> </ul><code>--config</code>, <code>-c</code> config-option<p>A TOML <code>&lt;KEY&gt; = &lt;VALUE&gt;</code> pair (such as you might find in a <code>ty.toml</code> configuration file) overriding a specific configuration option.</p> <p>Overrides of individual settings using this option always take precedence over all configuration files.</p> <code>--config-file</code> path<p>The path to a <code>ty.toml</code> file to use for configuration.</p> <p>While ty configuration can be included in a <code>pyproject.toml</code> file, it is not allowed in this context.</p> <p>May also be set with the <code>TY_CONFIG_FILE</code> environment variable.</p><code>--error</code> rule<p>Treat the given rule as having severity 'error'. Can be specified multiple times.</p> <code>--error-on-warning</code><p>Use exit code 1 if there are any warning-level diagnostics</p> <code>--exclude</code> exclude<p>Glob patterns for files to exclude from type checking.</p> <p>Uses gitignore-style syntax to exclude files and directories from type checking. Supports patterns like <code>tests/</code>, <code>*.tmp</code>, <code>**/__pycache__/**</code>.</p> <code>--exit-zero</code><p>Always use exit code 0, even when there are error-level diagnostics</p> <code>--extra-search-path</code> path<p>Additional path to use as a module-resolution source (can be passed multiple times)</p> <code>--help</code>, <code>-h</code><p>Print help (see a summary with '-h')</p> <code>--ignore</code> rule<p>Disables the rule. Can be specified multiple times.</p> <code>--output-format</code> output-format<p>The format to use for printing diagnostic messages</p> <p>Possible values:</p> <ul> <li><code>full</code>:  Print diagnostics verbosely, with context and helpful hints [default]</li> <li><code>concise</code>:  Print diagnostics concisely, one per line</li> </ul><code>--project</code> project<p>Run the command within the given project directory.</p> <p>All <code>pyproject.toml</code> files will be discovered by walking up the directory tree from the given project directory, as will the project's virtual environment (<code>.venv</code>) unless the <code>venv-path</code> option is set.</p> <p>Other command-line arguments (such as relative paths) will be resolved relative to the current working directory.</p> <code>--python</code> path<p>Path to the Python environment.</p> <p>ty uses the Python environment to resolve type information and third-party dependencies.</p> <p>If not specified, ty will attempt to infer it from the <code>VIRTUAL_ENV</code> or <code>CONDA_PREFIX</code> environment variables, or discover a <code>.venv</code> directory in the project root or working directory.</p> <p>If a path to a Python interpreter is provided, e.g., <code>.venv/bin/python3</code>, ty will attempt to find an environment two directories up from the interpreter's path, e.g., <code>.venv</code>. At this time, ty does not invoke the interpreter to determine the location of the environment. This means that ty will not resolve dynamic executables such as a shim.</p> <p>ty will search in the resolved environment's <code>site-packages</code> directories for type information and third-party imports.</p> <code>--python-platform</code>, <code>--platform</code> platform<p>Target platform to assume when resolving types.</p> <p>This is used to specialize the type of <code>sys.platform</code> and will affect the visibility of platform-specific functions and attributes. If the value is set to <code>all</code>, no assumptions are made about the target platform. If unspecified, the current system's platform will be used.</p> <code>--python-version</code>, <code>--target-version</code> version<p>Python version to assume when resolving types.</p> <p>The Python version affects allowed syntax, type definitions of the standard library, and type definitions of first- and third-party modules that are conditional on the Python version.</p> <p>If a version is not specified on the command line or in a configuration file, ty will try the following techniques in order of preference to determine a value: 1. Check for the <code>project.requires-python</code> setting in a <code>pyproject.toml</code> file and use the minimum version from the specified range 2. Check for an activated or configured Python environment and attempt to infer the Python version of that environment 3. Fall back to the latest stable Python version supported by ty (currently Python 3.13)</p> <p>Possible values:</p> <ul> <li><code>3.7</code></li> <li><code>3.8</code></li> <li><code>3.9</code></li> <li><code>3.10</code></li> <li><code>3.11</code></li> <li><code>3.12</code></li> <li><code>3.13</code></li> </ul><code>--quiet</code>, <code>-q</code><p>Use quiet output (or <code>-qq</code> for silent output)</p> <code>--respect-ignore-files</code><p>Respect file exclusions via <code>.gitignore</code> and other standard ignore files. Use <code>--no-respect-gitignore</code> to disable</p> <code>--typeshed</code>, <code>--custom-typeshed-dir</code> path<p>Custom directory to use for stdlib typeshed stubs</p> <code>--verbose</code>, <code>-v</code><p>Use verbose output (or <code>-vv</code> and <code>-vvv</code> for more verbose output)</p> <code>--warn</code> rule<p>Treat the given rule as having severity 'warn'. Can be specified multiple times.</p> <code>--watch</code>, <code>-W</code><p>Watch files for changes and recheck files related to the changed files</p>"},{"location":"reference/cli/#ty-server","title":"ty server","text":"<p>Start the language server</p> Usage <pre><code>ty server\n</code></pre> Options <code>--help</code>, <code>-h</code><p>Print help</p>"},{"location":"reference/cli/#ty-version","title":"ty version","text":"<p>Display ty's version</p> Usage <pre><code>ty version\n</code></pre> Options <code>--help</code>, <code>-h</code><p>Print help</p>"},{"location":"reference/cli/#ty-generate-shell-completion","title":"ty generate-shell-completion","text":"<p>Generate shell completion</p> Usage <pre><code>ty generate-shell-completion &lt;SHELL&gt;\n</code></pre> Arguments <code>SHELL</code> Options <code>--help</code>, <code>-h</code><p>Print help</p>"},{"location":"reference/cli/#ty-help","title":"ty help","text":"<p>Print this message or the help of the given subcommand(s)</p> Usage <pre><code>ty help [COMMAND]\n</code></pre>"},{"location":"reference/configuration/","title":"Configuration","text":""},{"location":"reference/configuration/#configuration","title":"Configuration","text":""},{"location":"reference/configuration/#rules","title":"<code>rules</code>","text":"<p>Configures the enabled rules and their severity.</p> <p>See the rules documentation for a list of all available rules.</p> <p>Valid severities are:</p> <ul> <li><code>ignore</code>: Disable the rule.</li> <li><code>warn</code>: Enable the rule and create a warning diagnostic.</li> <li><code>error</code>: Enable the rule and create an error diagnostic.   ty will exit with a non-zero code if any error diagnostics are emitted.</li> </ul> <p>Default value: <code>{...}</code></p> <p>Type: <code>dict[RuleName, \"ignore\" | \"warn\" | \"error\"]</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.rules]\npossibly-unresolved-reference = \"warn\"\ndivision-by-zero = \"ignore\"\n</code></pre>"},{"location":"reference/configuration/#environment","title":"<code>environment</code>","text":""},{"location":"reference/configuration/#extra-paths","title":"<code>extra-paths</code>","text":"<p>List of user-provided paths that should take first priority in the module resolution. Examples in other type checkers are mypy's <code>MYPYPATH</code> environment variable, or pyright's <code>stubPath</code> configuration setting.</p> <p>Default value: <code>[]</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.environment]\nextra-paths = [\"~/shared/my-search-path\"]\n</code></pre>"},{"location":"reference/configuration/#python","title":"<code>python</code>","text":"<p>Path to the Python installation from which ty resolves type information and third-party dependencies.</p> <p>ty will search in the path's <code>site-packages</code> directories for type information and third-party imports.</p> <p>This option is commonly used to specify the path to a virtual environment.</p> <p>Default value: <code>null</code></p> <p>Type: <code>str</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.environment]\npython = \"./.venv\"\n</code></pre>"},{"location":"reference/configuration/#python-platform","title":"<code>python-platform</code>","text":"<p>Specifies the target platform that will be used to analyze the source code. If specified, ty will understand conditions based on comparisons with <code>sys.platform</code>, such as are commonly found in typeshed to reflect the differing contents of the standard library across platforms. If <code>all</code> is specified, ty will assume that the source code can run on any platform.</p> <p>If no platform is specified, ty will use the current platform: - <code>win32</code> for Windows - <code>darwin</code> for macOS - <code>android</code> for Android - <code>ios</code> for iOS - <code>linux</code> for everything else</p> <p>Default value: <code>&lt;current-platform&gt;</code></p> <p>Type: <code>\"win32\" | \"darwin\" | \"android\" | \"ios\" | \"linux\" | \"all\" | str</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.environment]\n# Tailor type stubs and conditionalized type definitions to windows.\npython-platform = \"win32\"\n</code></pre>"},{"location":"reference/configuration/#python-version","title":"<code>python-version</code>","text":"<p>Specifies the version of Python that will be used to analyze the source code. The version should be specified as a string in the format <code>M.m</code> where <code>M</code> is the major version and <code>m</code> is the minor (e.g. <code>\"3.0\"</code> or <code>\"3.6\"</code>). If a version is provided, ty will generate errors if the source code makes use of language features that are not supported in that version.</p> <p>If a version is not specified, ty will try the following techniques in order of preference to determine a value: 1. Check for the <code>project.requires-python</code> setting in a <code>pyproject.toml</code> file    and use the minimum version from the specified range 2. Check for an activated or configured Python environment    and attempt to infer the Python version of that environment 3. Fall back to the default value (see below)</p> <p>For some language features, ty can also understand conditionals based on comparisons with <code>sys.version_info</code>. These are commonly found in typeshed, for example, to reflect the differing contents of the standard library across Python versions.</p> <p>Default value: <code>\"3.13\"</code></p> <p>Type: <code>\"3.7\" | \"3.8\" | \"3.9\" | \"3.10\" | \"3.11\" | \"3.12\" | \"3.13\" | &lt;major&gt;.&lt;minor&gt;</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.environment]\npython-version = \"3.12\"\n</code></pre>"},{"location":"reference/configuration/#root","title":"<code>root</code>","text":"<p>The root paths of the project, used for finding first-party modules.</p> <p>Accepts a list of directory paths searched in priority order (first has highest priority).</p> <p>If left unspecified, ty will try to detect common project layouts and initialize <code>root</code> accordingly:</p> <ul> <li>if a <code>./src</code> directory exists, include <code>.</code> and <code>./src</code> in the first party search path (src layout or flat)</li> <li>if a <code>./&lt;project-name&gt;/&lt;project-name&gt;</code> directory exists, include <code>.</code> and <code>./&lt;project-name&gt;</code> in the first party search path</li> <li>otherwise, default to <code>.</code> (flat layout)</li> </ul> <p>Besides, if a <code>./tests</code> directory exists and is not a package (i.e. it does not contain an <code>__init__.py</code> file), it will also be included in the first party search path.</p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.environment]\n# Multiple directories (priority order)\nroot = [\"./src\", \"./lib\", \"./vendor\"]\n</code></pre>"},{"location":"reference/configuration/#typeshed","title":"<code>typeshed</code>","text":"<p>Optional path to a \"typeshed\" directory on disk for us to use for standard-library types. If this is not provided, we will fallback to our vendored typeshed stubs for the stdlib, bundled as a zip file in the binary</p> <p>Default value: <code>null</code></p> <p>Type: <code>str</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.environment]\ntypeshed = \"/path/to/custom/typeshed\"\n</code></pre>"},{"location":"reference/configuration/#overrides","title":"<code>overrides</code>","text":"<p>Configuration override that applies to specific files based on glob patterns.</p> <p>An override allows you to apply different rule configurations to specific files or directories. Multiple overrides can match the same file, with later overrides take precedence.</p>"},{"location":"reference/configuration/#precedence","title":"Precedence","text":"<ul> <li>Later overrides in the array take precedence over earlier ones</li> <li>Override rules take precedence over global rules for matching files</li> </ul>"},{"location":"reference/configuration/#examples","title":"Examples","text":"<pre><code># Relax rules for test files\n[[tool.ty.overrides]]\ninclude = [\"tests/**\", \"**/test_*.py\"]\n[tool.ty.overrides.rules]\npossibly-unresolved-reference = \"warn\"\n# Ignore generated files but still check important ones\n[[tool.ty.overrides]]\ninclude = [\"generated/**\"]\nexclude = [\"generated/important.py\"]\n[tool.ty.overrides.rules]\npossibly-unresolved-reference = \"ignore\"\n</code></pre>"},{"location":"reference/configuration/#exclude","title":"<code>exclude</code>","text":"<p>A list of file and directory patterns to exclude from this override.</p> <p>Patterns follow a syntax similar to <code>.gitignore</code>. Exclude patterns take precedence over include patterns within the same override.</p> <p>If not specified, defaults to <code>[]</code> (excludes no files).</p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[[tool.ty.overrides]]\nexclude = [\n\"generated\",\n\"*.proto\",\n\"tests/fixtures/**\",\n\"!tests/fixtures/important.py\"  # Include this one file\n]\n</code></pre>"},{"location":"reference/configuration/#include","title":"<code>include</code>","text":"<p>A list of file and directory patterns to include for this override.</p> <p>The <code>include</code> option follows a similar syntax to <code>.gitignore</code> but reversed: Including a file or directory will make it so that it (and its contents) are affected by this override.</p> <p>If not specified, defaults to <code>[\"**\"]</code> (matches all files).</p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[[tool.ty.overrides]]\ninclude = [\n\"src\",\n\"tests\",\n]\n</code></pre>"},{"location":"reference/configuration/#rules_1","title":"<code>rules</code>","text":"<p>Rule overrides for files matching the include/exclude patterns.</p> <p>These rules will be merged with the global rules, with override rules taking precedence for matching files. You can set rules to different severity levels or disable them entirely.</p> <p>Default value: <code>{...}</code></p> <p>Type: <code>dict[RuleName, \"ignore\" | \"warn\" | \"error\"]</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[[tool.ty.overrides]]\ninclude = [\"src\"]\n[tool.ty.overrides.rules]\npossibly-unresolved-reference = \"ignore\"\n</code></pre>"},{"location":"reference/configuration/#src","title":"<code>src</code>","text":""},{"location":"reference/configuration/#exclude_1","title":"<code>exclude</code>","text":"<p>A list of file and directory patterns to exclude from type checking.</p> <p>Patterns follow a syntax similar to <code>.gitignore</code>:</p> <ul> <li><code>./src/</code> matches only a directory</li> <li><code>./src</code> matches both files and directories</li> <li><code>src</code> matches files or directories named <code>src</code></li> <li><code>*</code> matches any (possibly empty) sequence of characters (except <code>/</code>).</li> <li><code>**</code> matches zero or more path components.   This sequence must form a single path component, so both <code>**a</code> and <code>b**</code> are invalid and will result in an error.   A sequence of more than two consecutive <code>*</code> characters is also invalid.</li> <li><code>?</code> matches any single character except <code>/</code></li> <li><code>[abc]</code> matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode,   so e.g. <code>[0-9]</code> specifies any character between <code>0</code> and <code>9</code> inclusive. An unclosed bracket is invalid.</li> <li><code>!pattern</code> negates a pattern (undoes the exclusion of files that would otherwise be excluded)</li> </ul> <p>All paths are anchored relative to the project root (<code>src</code> only matches <code>&lt;project_root&gt;/src</code> and not <code>&lt;project_root&gt;/test/src</code>). To exclude any directory or file named <code>src</code>, use <code>**/src</code> instead.</p> <p>By default, ty excludes commonly ignored directories:</p> <ul> <li><code>**/.bzr/</code></li> <li><code>**/.direnv/</code></li> <li><code>**/.eggs/</code></li> <li><code>**/.git/</code></li> <li><code>**/.git-rewrite/</code></li> <li><code>**/.hg/</code></li> <li><code>**/.mypy_cache/</code></li> <li><code>**/.nox/</code></li> <li><code>**/.pants.d/</code></li> <li><code>**/.pytype/</code></li> <li><code>**/.ruff_cache/</code></li> <li><code>**/.svn/</code></li> <li><code>**/.tox/</code></li> <li><code>**/.venv/</code></li> <li><code>**/__pypackages__/</code></li> <li><code>**/_build/</code></li> <li><code>**/buck-out/</code></li> <li><code>**/dist/</code></li> <li><code>**/node_modules/</code></li> <li><code>**/venv/</code></li> </ul> <p>You can override any default exclude by using a negated pattern. For example, to re-include <code>dist</code> use <code>exclude = [\"!dist\"]</code></p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.src]\nexclude = [\n\"generated\",\n\"*.proto\",\n\"tests/fixtures/**\",\n\"!tests/fixtures/important.py\"  # Include this one file\n]\n</code></pre>"},{"location":"reference/configuration/#include_1","title":"<code>include</code>","text":"<p>A list of files and directories to check. The <code>include</code> option follows a similar syntax to <code>.gitignore</code> but reversed: Including a file or directory will make it so that it (and its contents) are type checked.</p> <ul> <li><code>./src/</code> matches only a directory</li> <li><code>./src</code> matches both files and directories</li> <li><code>src</code> matches a file or directory named <code>src</code></li> <li><code>*</code> matches any (possibly empty) sequence of characters (except <code>/</code>).</li> <li><code>**</code> matches zero or more path components.   This sequence must form a single path component, so both <code>**a</code> and <code>b**</code> are invalid and will result in an error.   A sequence of more than two consecutive <code>*</code> characters is also invalid.</li> <li><code>?</code> matches any single character except <code>/</code></li> <li><code>[abc]</code> matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode,   so e.g. <code>[0-9]</code> specifies any character between <code>0</code> and <code>9</code> inclusive. An unclosed bracket is invalid.</li> </ul> <p>All paths are anchored relative to the project root (<code>src</code> only matches <code>&lt;project_root&gt;/src</code> and not <code>&lt;project_root&gt;/test/src</code>).</p> <p><code>exclude</code> takes precedence over <code>include</code>.</p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.src]\ninclude = [\n\"src\",\n\"tests\",\n]\n</code></pre>"},{"location":"reference/configuration/#respect-ignore-files","title":"<code>respect-ignore-files</code>","text":"<p>Whether to automatically exclude files that are ignored by <code>.ignore</code>, <code>.gitignore</code>, <code>.git/info/exclude</code>, and global <code>gitignore</code> files. Enabled by default.</p> <p>Default value: <code>true</code></p> <p>Type: <code>bool</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.src]\nrespect-ignore-files = false\n</code></pre>"},{"location":"reference/configuration/#root_1","title":"<code>root</code>","text":"<p>[!WARN] \"Deprecated\" This option has been deprecated. Use <code>environment.root</code> instead.</p> <p>The root of the project, used for finding first-party modules.</p> <p>If left unspecified, ty will try to detect common project layouts and initialize <code>src.root</code> accordingly:</p> <ul> <li>if a <code>./src</code> directory exists, include <code>.</code> and <code>./src</code> in the first party search path (src layout or flat)</li> <li>if a <code>./&lt;project-name&gt;/&lt;project-name&gt;</code> directory exists, include <code>.</code> and <code>./&lt;project-name&gt;</code> in the first party search path</li> <li>otherwise, default to <code>.</code> (flat layout)</li> </ul> <p>Besides, if a <code>./tests</code> directory exists and is not a package (i.e. it does not contain an <code>__init__.py</code> file), it will also be included in the first party search path.</p> <p>Default value: <code>null</code></p> <p>Type: <code>str</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.src]\nroot = \"./app\"\n</code></pre>"},{"location":"reference/configuration/#terminal","title":"<code>terminal</code>","text":""},{"location":"reference/configuration/#error-on-warning","title":"<code>error-on-warning</code>","text":"<p>Use exit code 1 if there are any warning-level diagnostics.</p> <p>Defaults to <code>false</code>.</p> <p>Default value: <code>false</code></p> <p>Type: <code>bool</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.terminal]\n# Error if ty emits any warning-level diagnostics.\nerror-on-warning = true\n</code></pre>"},{"location":"reference/configuration/#output-format","title":"<code>output-format</code>","text":"<p>The format to use for printing diagnostic messages.</p> <p>Defaults to <code>full</code>.</p> <p>Default value: <code>full</code></p> <p>Type: <code>full | concise</code></p> <p>Example usage (<code>pyproject.toml</code>):</p> <pre><code>[tool.ty.terminal]\noutput-format = \"concise\"\n</code></pre>"},{"location":"reference/editor-settings/","title":"Editor settings","text":"<p>The editor settings supported by ty's language server, as well as the settings specific to ty's VS Code extension.</p>"},{"location":"reference/editor-settings/#pythontydisablelanguageservices","title":"<code>python.ty.disableLanguageServices</code>","text":"<p>Whether to disable the language services for the ty language server like code completion, hover, go to definition, etc.</p> <p>This is useful if you want to use ty exclusively for type checking and want to use another language server for features like code completion, hover, go to definition, etc.</p> <p>Default value: <code>false</code></p> <p>Type: <code>boolean</code></p> <p>Example usage:</p> <pre><code>{\n\"python.ty.disableLanguageServices\": true\n}\n</code></pre>"},{"location":"reference/editor-settings/#diagnosticmode","title":"<code>diagnosticMode</code>","text":"<p>Determines the scope of the diagnostics reported by the language server.</p> <ul> <li><code>openFilesOnly</code>: Diagnostics are reported only for files that are currently open in the editor.</li> <li><code>workspace</code>: Diagnostics are reported for all files in the workspace.</li> </ul> <p>Default value: <code>\"openFilesOnly\"</code></p> <p>Type: <code>\"workspace\" | \"openFilesOnly\"</code></p> <p>Example usage:</p> <pre><code>{\n\"ty.diagnosticMode\": \"workspace\"\n}\n</code></pre>"},{"location":"reference/editor-settings/#logfile","title":"<code>logFile</code>","text":"<p>Path to the file to which the language server writes its log messages. By default, ty writes log messages to stderr.</p> <p>Default value: <code>null</code></p> <p>Type: <code>string</code></p> <p>Example usage:</p> <pre><code>{\n\"ty.logFile\": \"~/path/to/ty.log\"\n}\n</code></pre>"},{"location":"reference/editor-settings/#loglevel","title":"<code>logLevel</code>","text":"<p>The log level to use for the language server.</p> <p>Default value: <code>\"info\"</code></p> <p>Type: <code>\"trace\" | \"debug\" | \"info\" | \"warn\" | \"error\"</code></p> <p>Example usage:</p> <pre><code>{\n\"ty.logLevel\": \"debug\"\n}\n</code></pre>"},{"location":"reference/editor-settings/#traceserver","title":"<code>trace.server</code>","text":"<p>The detail level at which messages between the language server and the editor (client) are logged. Refer to the LSP specification for more information.</p> <p>Default value: <code>\"off\"</code></p> <p>Type: <code>\"off\" | \"messages\" | \"verbose\"</code></p> <p>Example usage:</p> <pre><code>{\n\"ty.trace.server\": \"messages\"\n}\n</code></pre>"},{"location":"reference/editor-settings/#vs-code-specific","title":"VS Code specific","text":"<p>The following settings are specific to ty's VS Code extension.</p>"},{"location":"reference/editor-settings/#importstrategy","title":"<code>importStrategy</code>","text":"<p>Strategy for loading the <code>ty</code> executable.</p> <ul> <li><code>fromEnvironment</code> finds ty in the environment, falling back to the bundled version</li> <li><code>useBundled</code> uses the version bundled with the extension</li> </ul> <p>Default value: <code>\"fromEnvironment\"</code></p> <p>Type: <code>\"fromEnvironment\" | \"useBundled\"</code></p> <p>Example usage:</p> <pre><code>{\n\"ty.importStrategy\": \"useBundled\"\n}\n</code></pre>"},{"location":"reference/editor-settings/#interpreter","title":"<code>interpreter</code>","text":"<p>A list of paths to Python interpreters. Even though this is a list, only the first interpreter is used.</p> <p>The interpreter path is used to find the <code>ty</code> executable when <code>ty.importStrategy</code> is set to <code>fromEnvironment</code>.</p> <p>Default value: <code>[]</code></p> <p>Type: <code>string[]</code></p> <p>Example usage:</p> <pre><code>{\n\"ty.interpreter\": [\"/home/user/.local/bin/python\"]\n}\n</code></pre>"},{"location":"reference/editor-settings/#path","title":"<code>path</code>","text":"<p>A list of path to <code>ty</code> executables.</p> <p>The extension uses the first executable that exists. This setting takes precedence over the <code>ty.importStrategy</code> setting.</p> <p>Default value: <code>[]</code></p> <p>Type: <code>string[]</code></p> <p>Example usage:</p> <pre><code>{\n\"ty.path\": [\"/home/user/.local/bin/ty\"]\n}\n</code></pre>"},{"location":"reference/environment/","title":"Environment variables","text":"<p>ty defines and respects the following environment variables:</p>"},{"location":"reference/environment/#ty_log","title":"<code>TY_LOG</code>","text":"<p>If set, ty will use this value as the log level for its <code>--verbose</code> output. Accepts any filter compatible with the <code>tracing_subscriber</code> crate.</p> <p>For example:</p> <ul> <li><code>TY_LOG=uv=debug</code> is the equivalent of <code>-vv</code> to the command line</li> <li><code>TY_LOG=trace</code> will enable all trace-level logging.</li> </ul> <p>See the tracing documentation for more.</p>"},{"location":"reference/environment/#ty_log_profile","title":"<code>TY_LOG_PROFILE</code>","text":"<p>If set to <code>\"1\"</code> or <code>\"true\"</code>, ty will enable flamegraph profiling. This creates a <code>tracing.folded</code> file that can be used to generate flame graphs for performance analysis.</p>"},{"location":"reference/environment/#ty_max_parallelism","title":"<code>TY_MAX_PARALLELISM</code>","text":"<p>Specifies an upper limit for the number of tasks ty is allowed to run in parallel.</p> <p>For example, how many files should be checked in parallel. This isn't the same as a thread limit. ty may spawn additional threads when necessary, e.g. to watch for file system changes or a dedicated UI thread.</p>"},{"location":"reference/environment/#externally-defined-variables","title":"Externally-defined variables","text":"<p>ty also reads the following externally defined environment variables:</p>"},{"location":"reference/environment/#conda_prefix","title":"<code>CONDA_PREFIX</code>","text":"<p>Used to detect an activated Conda environment location. If both <code>VIRTUAL_ENV</code> and <code>CONDA_PREFIX</code> are present, <code>VIRTUAL_ENV</code> will be preferred.</p>"},{"location":"reference/environment/#rayon_num_threads","title":"<code>RAYON_NUM_THREADS</code>","text":"<p>Specifies an upper limit for the number of threads ty uses when performing work in parallel. Equivalent to <code>TY_MAX_PARALLELISM</code>.</p> <p>This is a standard Rayon environment variable.</p>"},{"location":"reference/environment/#virtual_env","title":"<code>VIRTUAL_ENV</code>","text":"<p>Used to detect an activated virtual environment.</p>"},{"location":"reference/environment/#xdg_config_home","title":"<code>XDG_CONFIG_HOME</code>","text":"<p>Path to user-level configuration directory on Unix systems.</p>"},{"location":"reference/exit-codes/","title":"Exit codes","text":"<p>The ty command line interface uses the following exit codes:</p> Exit code Description <code>0</code> no violations with severity <code>error</code> or higher were found <code>1</code> violations with severity <code>error</code> or higher were found <code>2</code> invalid CLI options <code>101</code> internal error <p>ty supports two command line arguments that change how exit codes work:</p> <ul> <li><code>--exit-zero</code>: ty will exit with <code>0</code> even if violations were found.</li> <li><code>--error-on-warning</code>: ty will exit with <code>1</code> if it finds any violations with severity <code>warning</code> or     higher.</li> </ul>"},{"location":"reference/rules/","title":"Rules","text":""},{"location":"reference/rules/#rules","title":"Rules","text":""},{"location":"reference/rules/#byte-string-type-annotation","title":"<code>byte-string-type-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for byte-strings in type annotation positions.</p> <p>Why is this bad?</p> <p>Static analysis tools like ty can't analyze type annotations that use byte-string notation.</p> <p>Examples</p> <pre><code>def test(): -&gt; b\"int\":\n...\n</code></pre> <p>Use instead: <pre><code>def test(): -&gt; \"int\":\n...\n</code></pre></p>"},{"location":"reference/rules/#call-non-callable","title":"<code>call-non-callable</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls to non-callable objects.</p> <p>Why is this bad?</p> <p>Calling a non-callable object will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>4()  # TypeError: 'int' object is not callable\n</code></pre>"},{"location":"reference/rules/#conflicting-argument-forms","title":"<code>conflicting-argument-forms</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks whether an argument is used as both a value and a type form in a call.</p> <p>Why is this bad?</p> <p>Such calls have confusing semantics and often indicate a logic error.</p> <p>Examples</p> <pre><code>from typing import reveal_type\nfrom ty_extensions import is_singleton\nif flag:\nf = repr  # Expects a value\nelse:\nf = is_singleton  # Expects a type form\nf(int)  # error\n</code></pre>"},{"location":"reference/rules/#conflicting-declarations","title":"<code>conflicting-declarations</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks whether a variable has been declared as two conflicting types.</p> <p>Why is this bad</p> <p>A variable with two conflicting declarations likely indicates a mistake. Moreover, it could lead to incorrect or ill-defined type inference for other code that relies on these variables.</p> <p>Examples</p> <pre><code>if b:\na: int\nelse:\na: str\na = 1\n</code></pre>"},{"location":"reference/rules/#conflicting-metaclass","title":"<code>conflicting-metaclass</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions where the metaclass of the class being created would not be a subclass of the metaclasses of all the class's bases.</p> <p>Why is it bad?</p> <p>Such a class definition raises a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class M1(type): ...\nclass M2(type): ...\nclass A(metaclass=M1): ...\nclass B(metaclass=M2): ...\n# TypeError: metaclass conflict\nclass C(A, B): ...\n</code></pre>"},{"location":"reference/rules/#cyclic-class-definition","title":"<code>cyclic-class-definition</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions in stub files that inherit (directly or indirectly) from themselves.</p> <p>Why is it bad?</p> <p>Although forward references are natively supported in stub files, inheritance cycles are still disallowed, as it is impossible to resolve a consistent method resolution order for a class that inherits from itself.</p> <p>Examples</p> <pre><code># foo.pyi\nclass A(B): ...\nclass B(A): ...\n</code></pre>"},{"location":"reference/rules/#duplicate-base","title":"<code>duplicate-base</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions with duplicate bases.</p> <p>Why is this bad?</p> <p>Class definitions with duplicate bases raise <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A: ...\n# TypeError: duplicate base class\nclass B(A, A): ...\n</code></pre>"},{"location":"reference/rules/#duplicate-kw-only","title":"<code>duplicate-kw-only</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for dataclass definitions with more than one field annotated with <code>KW_ONLY</code>.</p> <p>Why is this bad?</p> <p><code>dataclasses.KW_ONLY</code> is a special marker used to emulate the <code>*</code> syntax in normal signatures. It can only be used once per dataclass.</p> <p>Attempting to annotate two different fields with it will lead to a runtime error.</p> <p>Examples</p> <pre><code>from dataclasses import dataclass, KW_ONLY\n@dataclass\nclass A:  # Crash at runtime\nb: int\n_1: KW_ONLY\nc: str\n_2: KW_ONLY\nd: bytes\n</code></pre>"},{"location":"reference/rules/#escape-character-in-forward-annotation","title":"<code>escape-character-in-forward-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>TODO #14889</p>"},{"location":"reference/rules/#fstring-type-annotation","title":"<code>fstring-type-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for f-strings in type annotation positions.</p> <p>Why is this bad?</p> <p>Static analysis tools like ty can't analyze type annotations that use f-string notation.</p> <p>Examples</p> <pre><code>def test(): -&gt; f\"int\":\n...\n</code></pre> <p>Use instead: <pre><code>def test(): -&gt; \"int\":\n...\n</code></pre></p>"},{"location":"reference/rules/#implicit-concatenated-string-type-annotation","title":"<code>implicit-concatenated-string-type-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for implicit concatenated strings in type annotation positions.</p> <p>Why is this bad?</p> <p>Static analysis tools like ty can't analyze type annotations that use implicit concatenated strings.</p> <p>Examples</p> <pre><code>def test(): -&gt; \"Literal[\" \"5\" \"]\":\n...\n</code></pre> <p>Use instead: <pre><code>def test(): -&gt; \"Literal[5]\":\n...\n</code></pre></p>"},{"location":"reference/rules/#inconsistent-mro","title":"<code>inconsistent-mro</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for classes with an inconsistent method resolution order (MRO).</p> <p>Why is this bad?</p> <p>Classes with an inconsistent MRO will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A: ...\nclass B(A): ...\n# TypeError: Cannot create a consistent method resolution order\nclass C(A, B): ...\n</code></pre>"},{"location":"reference/rules/#index-out-of-bounds","title":"<code>index-out-of-bounds</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for attempts to use an out of bounds index to get an item from a container.</p> <p>Why is this bad?</p> <p>Using an out of bounds index will raise an <code>IndexError</code> at runtime.</p> <p>Examples</p> <pre><code>t = (0, 1, 2)\nt[3]  # IndexError: tuple index out of range\n</code></pre>"},{"location":"reference/rules/#instance-layout-conflict","title":"<code>instance-layout-conflict</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for classes definitions which will fail at runtime due to \"instance memory layout conflicts\".</p> <p>This error is usually caused by attempting to combine multiple classes that define non-empty <code>__slots__</code> in a class's Method Resolution Order (MRO), or by attempting to combine multiple builtin classes in a class's MRO.</p> <p>Why is this bad?</p> <p>Inheriting from bases with conflicting instance memory layouts will lead to a <code>TypeError</code> at runtime.</p> <p>An instance memory layout conflict occurs when CPython cannot determine the memory layout instances of a class should have, because the instance memory layout of one of its bases conflicts with the instance memory layout of one or more of its other bases.</p> <p>For example, if a Python class defines non-empty <code>__slots__</code>, this will impact the memory layout of instances of that class. Multiple inheritance from more than one different class defining non-empty <code>__slots__</code> is not allowed:</p> <pre><code>class A:\n__slots__ = (\"a\", \"b\")\nclass B:\n__slots__ = (\"a\", \"b\")  # Even if the values are the same\n# TypeError: multiple bases have instance lay-out conflict\nclass C(A, B): ...\n</code></pre> <p>An instance layout conflict can also be caused by attempting to use multiple inheritance with two builtin classes, due to the way that these classes are implemented in a CPython C extension:</p> <pre><code>class A(int, float): ...  # TypeError: multiple bases have instance lay-out conflict\n</code></pre> <p>Note that pure-Python classes with no <code>__slots__</code>, or pure-Python classes with empty <code>__slots__</code>, are always compatible:</p> <pre><code>class A: ...\nclass B:\n__slots__ = ()\nclass C:\n__slots__ = (\"a\", \"b\")\n# fine\nclass D(A, B, C): ...\n</code></pre> <p>Known problems</p> <p>Classes that have \"dynamic\" definitions of <code>__slots__</code> (definitions do not consist of string literals, or tuples of string literals) are not currently considered solid bases by ty.</p> <p>Additionally, this check is not exhaustive: many C extensions (including several in the standard library) define classes that use extended memory layouts and thus cannot coexist in a single MRO. Since it is currently not possible to represent this fact in stub files, having a full knowledge of these classes is also impossible. When it comes to classes that do not define <code>__slots__</code> at the Python level, therefore, ty, currently only hard-codes a number of cases where it knows that a class will produce instances with an atypical memory layout.</p> <p>Further reading</p> <ul> <li>CPython documentation: <code>__slots__</code></li> <li>CPython documentation: Method Resolution Order</li> </ul>"},{"location":"reference/rules/#invalid-argument-type","title":"<code>invalid-argument-type</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects call arguments whose type is not assignable to the corresponding typed parameter.</p> <p>Why is this bad?</p> <p>Passing an argument of a type the function (or callable object) does not accept violates the expectations of the function author and may cause unexpected runtime errors within the body of the function.</p> <p>Examples</p> <pre><code>def func(x: int): ...\nfunc(\"foo\")  # error: [invalid-argument-type]\n</code></pre>"},{"location":"reference/rules/#invalid-assignment","title":"<code>invalid-assignment</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for assignments where the type of the value is not assignable to the type of the assignee.</p> <p>Why is this bad?</p> <p>Such assignments break the rules of the type system and weaken a type checker's ability to accurately reason about your code.</p> <p>Examples</p> <pre><code>a: int = ''\n</code></pre>"},{"location":"reference/rules/#invalid-attribute-access","title":"<code>invalid-attribute-access</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for assignments to class variables from instances and assignments to instance variables from its class.</p> <p>Why is this bad?</p> <p>Incorrect assignments break the rules of the type system and weaken a type checker's ability to accurately reason about your code.</p> <p>Examples</p> <pre><code>class C:\nclass_var: ClassVar[int] = 1\ninstance_var: int\nC.class_var = 3  # okay\nC().class_var = 3  # error: Cannot assign to class variable\nC().instance_var = 3  # okay\nC.instance_var = 3  # error: Cannot assign to instance variable\n</code></pre>"},{"location":"reference/rules/#invalid-base","title":"<code>invalid-base</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions that have bases which are not instances of <code>type</code>.</p> <p>Why is this bad?</p> <p>Class definitions with bases like this will lead to <code>TypeError</code> being raised at runtime.</p> <p>Examples</p> <pre><code>class A(42): ...  # error: [invalid-base]\n</code></pre>"},{"location":"reference/rules/#invalid-context-manager","title":"<code>invalid-context-manager</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for expressions used in <code>with</code> statements that do not implement the context manager protocol.</p> <p>Why is this bad?</p> <p>Such a statement will raise <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code># TypeError: 'int' object does not support the context manager protocol\nwith 1:\nprint(2)\n</code></pre>"},{"location":"reference/rules/#invalid-declaration","title":"<code>invalid-declaration</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for declarations where the inferred type of an existing symbol is not assignable to its post-hoc declared type.</p> <p>Why is this bad?</p> <p>Such declarations break the rules of the type system and weaken a type checker's ability to accurately reason about your code.</p> <p>Examples</p> <pre><code>a = 1\na: str\n</code></pre>"},{"location":"reference/rules/#invalid-exception-caught","title":"<code>invalid-exception-caught</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for exception handlers that catch non-exception classes.</p> <p>Why is this bad?</p> <p>Catching classes that do not inherit from <code>BaseException</code> will raise a TypeError at runtime.</p> <p>Example</p> <pre><code>try:\n1 / 0\nexcept 1:\n...\n</code></pre> <p>Use instead: <pre><code>try:\n1 / 0\nexcept ZeroDivisionError:\n...\n</code></pre></p> <p>References</p> <ul> <li>Python documentation: except clause</li> <li>Python documentation: Built-in Exceptions</li> </ul> <p>Ruff rule</p> <p>This rule corresponds to Ruff's <code>except-with-non-exception-classes</code> (<code>B030</code>)</p>"},{"location":"reference/rules/#invalid-generic-class","title":"<code>invalid-generic-class</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for the creation of invalid generic classes</p> <p>Why is this bad?</p> <p>There are several requirements that you must follow when defining a generic class.</p> <p>Examples</p> <pre><code>from typing import Generic, TypeVar\nT = TypeVar(\"T\")  # okay\n# error: class uses both PEP-695 syntax and legacy syntax\nclass C[U](Generic[T]): ...\n</code></pre> <p>References</p> <ul> <li>Typing spec: Generics</li> </ul>"},{"location":"reference/rules/#invalid-key","title":"<code>invalid-key</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for subscript accesses with invalid keys.</p> <p>Why is this bad?</p> <p>Using an invalid key will raise a <code>KeyError</code> at runtime.</p> <p>Examples</p> <pre><code>from typing import TypedDict\nclass Person(TypedDict):\nname: str\nage: int\nalice = Person(name=\"Alice\", age=30)\nalice[\"height\"]  # KeyError: 'height'\n</code></pre>"},{"location":"reference/rules/#invalid-legacy-type-variable","title":"<code>invalid-legacy-type-variable</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for the creation of invalid legacy <code>TypeVar</code>s</p> <p>Why is this bad?</p> <p>There are several requirements that you must follow when creating a legacy <code>TypeVar</code>.</p> <p>Examples</p> <pre><code>from typing import TypeVar\nT = TypeVar(\"T\")  # okay\nQ = TypeVar(\"S\")  # error: TypeVar name must match the variable it's assigned to\nT = TypeVar(\"T\")  # error: TypeVars should not be redefined\n# error: TypeVar must be immediately assigned to a variable\ndef f(t: TypeVar(\"U\")): ...\n</code></pre> <p>References</p> <ul> <li>Typing spec: Generics</li> </ul>"},{"location":"reference/rules/#invalid-metaclass","title":"<code>invalid-metaclass</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for arguments to <code>metaclass=</code> that are invalid.</p> <p>Why is this bad?</p> <p>Python allows arbitrary expressions to be used as the argument to <code>metaclass=</code>. These expressions, however, need to be callable and accept the same arguments as <code>type.__new__</code>.</p> <p>Example</p> <pre><code>def f(): ...\n# TypeError: f() takes 0 positional arguments but 3 were given\nclass B(metaclass=f): ...\n</code></pre> <p>References</p> <ul> <li>Python documentation: Metaclasses</li> </ul>"},{"location":"reference/rules/#invalid-overload","title":"<code>invalid-overload</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for various invalid <code>@overload</code> usages.</p> <p>Why is this bad?</p> <p>The <code>@overload</code> decorator is used to define functions and methods that accepts different combinations of arguments and return different types based on the arguments passed. This is mainly beneficial for type checkers. But, if the <code>@overload</code> usage is invalid, the type checker may not be able to provide correct type information.</p> <p>Example</p> <p>Defining only one overload:</p> <pre><code>from typing import overload\n@overload\ndef foo(x: int) -&gt; int: ...\ndef foo(x: int | None) -&gt; int | None:\nreturn x\n</code></pre> <p>Or, not providing an implementation for the overloaded definition:</p> <pre><code>from typing import overload\n@overload\ndef foo() -&gt; None: ...\n@overload\ndef foo(x: int) -&gt; int: ...\n</code></pre> <p>References</p> <ul> <li>Python documentation: <code>@overload</code></li> </ul>"},{"location":"reference/rules/#invalid-parameter-default","title":"<code>invalid-parameter-default</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for default values that can't be assigned to the parameter's annotated type.</p> <p>Why is this bad?</p> <p>This breaks the rules of the type system and weakens a type checker's ability to accurately reason about your code.</p> <p>Examples</p> <pre><code>def f(a: int = ''): ...\n</code></pre>"},{"location":"reference/rules/#invalid-protocol","title":"<code>invalid-protocol</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for invalidly defined protocol classes.</p> <p>Why is this bad?</p> <p>An invalidly defined protocol class may lead to the type checker inferring unexpected things. It may also lead to <code>TypeError</code>s at runtime.</p> <p>Examples</p> <p>A <code>Protocol</code> class cannot inherit from a non-<code>Protocol</code> class; this raises a <code>TypeError</code> at runtime:</p> <pre><code>&gt;&gt;&gt; from typing import Protocol\n&gt;&gt;&gt; class Foo(int, Protocol): ...\n...\nTraceback (most recent call last):\n  File \"&lt;python-input-1&gt;\", line 1, in &lt;module&gt;\nclass Foo(int, Protocol): ...\nTypeError: Protocols can only inherit from other protocols, got &lt;class 'int'&gt;\n</code></pre>"},{"location":"reference/rules/#invalid-raise","title":"<code>invalid-raise</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>Checks for <code>raise</code> statements that raise non-exceptions or use invalid causes for their raised exceptions.</p> <p>Why is this bad?</p> <p>Only subclasses or instances of <code>BaseException</code> can be raised. For an exception's cause, the same rules apply, except that <code>None</code> is also permitted. Violating these rules results in a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>def f():\ntry:\nsomething()\nexcept NameError:\nraise \"oops!\" from f\ndef g():\nraise NotImplemented from 42\n</code></pre> <p>Use instead: <pre><code>def f():\ntry:\nsomething()\nexcept NameError as e:\nraise RuntimeError(\"oops!\") from e\ndef g():\nraise NotImplementedError from None\n</code></pre></p> <p>References</p> <ul> <li>Python documentation: The <code>raise</code> statement</li> <li>Python documentation: Built-in Exceptions</li> </ul>"},{"location":"reference/rules/#invalid-return-type","title":"<code>invalid-return-type</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects returned values that can't be assigned to the function's annotated return type.</p> <p>Why is this bad?</p> <p>Returning an object of a type incompatible with the annotated return type may cause confusion to the user calling the function.</p> <p>Examples</p> <pre><code>def func() -&gt; int:\nreturn \"a\"  # error: [invalid-return-type]\n</code></pre>"},{"location":"reference/rules/#invalid-super-argument","title":"<code>invalid-super-argument</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects <code>super()</code> calls where: - the first argument is not a valid class literal, or - the second argument is not an instance or subclass of the first argument.</p> <p>Why is this bad?</p> <p><code>super(type, obj)</code> expects: - the first argument to be a class, - and the second argument to satisfy one of the following:   - <code>isinstance(obj, type)</code> is <code>True</code>   - <code>issubclass(obj, type)</code> is <code>True</code></p> <p>Violating this relationship will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A:\n...\nclass B(A):\n...\nsuper(A, B())  # it's okay! `A` satisfies `isinstance(B(), A)`\nsuper(A(), B()) # error: `A()` is not a class\nsuper(B, A())  # error: `A()` does not satisfy `isinstance(A(), B)`\nsuper(B, A)  # error: `A` does not satisfy `issubclass(A, B)`\n</code></pre> <p>References</p> <ul> <li>Python documentation: super()</li> </ul>"},{"location":"reference/rules/#invalid-syntax-in-forward-annotation","title":"<code>invalid-syntax-in-forward-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>TODO #14889</p>"},{"location":"reference/rules/#invalid-type-alias-type","title":"<code>invalid-type-alias-type</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for the creation of invalid <code>TypeAliasType</code>s</p> <p>Why is this bad?</p> <p>There are several requirements that you must follow when creating a <code>TypeAliasType</code>.</p> <p>Examples</p> <pre><code>from typing import TypeAliasType\nIntOrStr = TypeAliasType(\"IntOrStr\", int | str)  # okay\nNewAlias = TypeAliasType(get_name(), int)        # error: TypeAliasType name must be a string literal\n</code></pre>"},{"location":"reference/rules/#invalid-type-checking-constant","title":"<code>invalid-type-checking-constant</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for a value other than <code>False</code> assigned to the <code>TYPE_CHECKING</code> variable, or an annotation not assignable from <code>bool</code>.</p> <p>Why is this bad?</p> <p>The name <code>TYPE_CHECKING</code> is reserved for a flag that can be used to provide conditional code seen only by the type checker, and not at runtime. Normally this flag is imported from <code>typing</code> or <code>typing_extensions</code>, but it can also be defined locally. If defined locally, it must be assigned the value <code>False</code> at runtime; the type checker will consider its value to be <code>True</code>. If annotated, it must be annotated as a type that can accept <code>bool</code> values.</p> <p>Examples</p> <pre><code>TYPE_CHECKING: str\nTYPE_CHECKING = ''\n</code></pre>"},{"location":"reference/rules/#invalid-type-form","title":"<code>invalid-type-form</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for expressions that are used as type expressions but cannot validly be interpreted as such.</p> <p>Why is this bad?</p> <p>Such expressions cannot be understood by ty. In some cases, they might raise errors at runtime.</p> <p>Examples</p> <pre><code>from typing import Annotated\na: type[1]  # `1` is not a type\nb: Annotated[int]  # `Annotated` expects at least two arguments\n</code></pre>"},{"location":"reference/rules/#invalid-type-guard-call","title":"<code>invalid-type-guard-call</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for type guard function calls without a valid target.</p> <p>Why is this bad?</p> <p>The first non-keyword non-variadic argument to a type guard function is its target and must map to a symbol.</p> <p>Starred (<code>is_str(*a)</code>), literal (<code>is_str(42)</code>) and other non-symbol-like expressions are invalid as narrowing targets.</p> <p>Examples</p> <pre><code>from typing import TypeIs\ndef f(v: object) -&gt; TypeIs[int]: ...\nf()  # Error\nf(*a)  # Error\nf(10)  # Error\n</code></pre>"},{"location":"reference/rules/#invalid-type-guard-definition","title":"<code>invalid-type-guard-definition</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for type guard functions without a first non-self-like non-keyword-only non-variadic parameter.</p> <p>Why is this bad?</p> <p>Type narrowing functions must accept at least one positional argument (non-static methods must accept another in addition to <code>self</code>/<code>cls</code>).</p> <p>Extra parameters/arguments are allowed but do not affect narrowing.</p> <p>Examples</p> <pre><code>from typing import TypeIs\ndef f() -&gt; TypeIs[int]: ...  # Error, no parameter\ndef f(*, v: object) -&gt; TypeIs[int]: ...  # Error, no positional arguments allowed\ndef f(*args: object) -&gt; TypeIs[int]: ... # Error, expect variadic arguments\nclass C:\ndef f(self) -&gt; TypeIs[int]: ...  # Error, only positional argument expected is `self`\n</code></pre>"},{"location":"reference/rules/#invalid-type-variable-constraints","title":"<code>invalid-type-variable-constraints</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for constrained type variables with only one constraint.</p> <p>Why is this bad?</p> <p>A constrained type variable must have at least two constraints.</p> <p>Examples</p> <pre><code>from typing import TypeVar\nT = TypeVar('T', str)  # invalid constrained TypeVar\n</code></pre> <p>Use instead: <pre><code>T = TypeVar('T', str, int)  # valid constrained TypeVar\n# or\nT = TypeVar('T', bound=str)  # valid bound TypeVar\n</code></pre></p>"},{"location":"reference/rules/#missing-argument","title":"<code>missing-argument</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for missing required arguments in a call.</p> <p>Why is this bad?</p> <p>Failing to provide a required argument will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>def func(x: int): ...\nfunc()  # TypeError: func() missing 1 required positional argument: 'x'\n</code></pre>"},{"location":"reference/rules/#no-matching-overload","title":"<code>no-matching-overload</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls to an overloaded function that do not match any of the overloads.</p> <p>Why is this bad?</p> <p>Failing to provide the correct arguments to one of the overloads will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>@overload\ndef func(x: int): ...\n@overload\ndef func(x: bool): ...\nfunc(\"string\")  # error: [no-matching-overload]\n</code></pre>"},{"location":"reference/rules/#non-subscriptable","title":"<code>non-subscriptable</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for subscripting objects that do not support subscripting.</p> <p>Why is this bad?</p> <p>Subscripting an object that does not support it will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>4[1]  # TypeError: 'int' object is not subscriptable\n</code></pre>"},{"location":"reference/rules/#not-iterable","title":"<code>not-iterable</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for objects that are not iterable but are used in a context that requires them to be.</p> <p>Why is this bad?</p> <p>Iterating over an object that is not iterable will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>for i in 34:  # TypeError: 'int' object is not iterable\npass\n</code></pre>"},{"location":"reference/rules/#parameter-already-assigned","title":"<code>parameter-already-assigned</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls which provide more than one argument for a single parameter.</p> <p>Why is this bad?</p> <p>Providing multiple values for a single parameter will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>def f(x: int) -&gt; int: ...\nf(1, x=2)  # Error raised here\n</code></pre>"},{"location":"reference/rules/#raw-string-type-annotation","title":"<code>raw-string-type-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for raw-strings in type annotation positions.</p> <p>Why is this bad?</p> <p>Static analysis tools like ty can't analyze type annotations that use raw-string notation.</p> <p>Examples</p> <pre><code>def test(): -&gt; r\"int\":\n...\n</code></pre> <p>Use instead: <pre><code>def test(): -&gt; \"int\":\n...\n</code></pre></p>"},{"location":"reference/rules/#static-assert-error","title":"<code>static-assert-error</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Makes sure that the argument of <code>static_assert</code> is statically known to be true.</p> <p>Why is this bad?</p> <p>A <code>static_assert</code> call represents an explicit request from the user for the type checker to emit an error if the argument cannot be verified to evaluate to <code>True</code> in a boolean context.</p> <p>Examples</p> <pre><code>from ty_extensions import static_assert\nstatic_assert(1 + 1 == 3)  # error: evaluates to `False`\nstatic_assert(int(2.0 * 3.0) == 6)  # error: does not have a statically known truthiness\n</code></pre>"},{"location":"reference/rules/#subclass-of-final-class","title":"<code>subclass-of-final-class</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for classes that subclass final classes.</p> <p>Why is this bad?</p> <p>Decorating a class with <code>@final</code> declares to the type checker that it should not be subclassed.</p> <p>Example</p> <pre><code>from typing import final\n@final\nclass A: ...\nclass B(A): ...  # Error raised here\n</code></pre>"},{"location":"reference/rules/#too-many-positional-arguments","title":"<code>too-many-positional-arguments</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls that pass more positional arguments than the callable can accept.</p> <p>Why is this bad?</p> <p>Passing too many positional arguments will raise <code>TypeError</code> at runtime.</p> <p>Example</p> <pre><code>def f(): ...\nf(\"foo\")  # Error raised here\n</code></pre>"},{"location":"reference/rules/#type-assertion-failure","title":"<code>type-assertion-failure</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for <code>assert_type()</code> and <code>assert_never()</code> calls where the actual type is not the same as the asserted type.</p> <p>Why is this bad?</p> <p><code>assert_type()</code> allows confirming the inferred type of a certain value.</p> <p>Example</p> <pre><code>def _(x: int):\nassert_type(x, int)  # fine\nassert_type(x, str)  # error: Actual type does not match asserted type\n</code></pre>"},{"location":"reference/rules/#unavailable-implicit-super-arguments","title":"<code>unavailable-implicit-super-arguments</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects invalid <code>super()</code> calls where implicit arguments like the enclosing class or first method argument are unavailable.</p> <p>Why is this bad?</p> <p>When <code>super()</code> is used without arguments, Python tries to find two things: the nearest enclosing class and the first argument of the immediately enclosing function (typically self or cls). If either of these is missing, the call will fail at runtime with a <code>RuntimeError</code>.</p> <p>Examples</p> <pre><code>super()  # error: no enclosing class or function found\ndef func():\nsuper()  # error: no enclosing class or first argument exists\nclass A:\nf = super()  # error: no enclosing function to provide the first argument\ndef method(self):\ndef nested():\nsuper()  # error: first argument does not exist in this nested function\nlambda: super()  # error: first argument does not exist in this lambda\n(super() for _ in range(10))  # error: argument is not available in generator expression\nsuper()  # okay! both enclosing class and first argument are available\n</code></pre> <p>References</p> <ul> <li>Python documentation: super()</li> </ul>"},{"location":"reference/rules/#unknown-argument","title":"<code>unknown-argument</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for keyword arguments in calls that don't match any parameter of the callable.</p> <p>Why is this bad?</p> <p>Providing an unknown keyword argument will raise <code>TypeError</code> at runtime.</p> <p>Example</p> <pre><code>def f(x: int) -&gt; int: ...\nf(x=1, y=2)  # Error raised here\n</code></pre>"},{"location":"reference/rules/#unresolved-attribute","title":"<code>unresolved-attribute</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for unresolved attributes.</p> <p>Why is this bad?</p> <p>Accessing an unbound attribute will raise an <code>AttributeError</code> at runtime. An unresolved attribute is not guaranteed to exist from the type alone, so this could also indicate that the object is not of the type that the user expects.</p> <p>Examples</p> <pre><code>class A: ...\nA().foo  # AttributeError: 'A' object has no attribute 'foo'\n</code></pre>"},{"location":"reference/rules/#unresolved-import","title":"<code>unresolved-import</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for import statements for which the module cannot be resolved.</p> <p>Why is this bad?</p> <p>Importing a module that cannot be resolved will raise a <code>ModuleNotFoundError</code> at runtime.</p> <p>Examples</p> <pre><code>import foo  # ModuleNotFoundError: No module named 'foo'\n</code></pre>"},{"location":"reference/rules/#unresolved-reference","title":"<code>unresolved-reference</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for references to names that are not defined.</p> <p>Why is this bad?</p> <p>Using an undefined variable will raise a <code>NameError</code> at runtime.</p> <p>Example</p> <pre><code>print(x)  # NameError: name 'x' is not defined\n</code></pre>"},{"location":"reference/rules/#unsupported-bool-conversion","title":"<code>unsupported-bool-conversion</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for bool conversions where the object doesn't correctly implement <code>__bool__</code>.</p> <p>Why is this bad?</p> <p>If an exception is raised when you attempt to evaluate the truthiness of an object, using the object in a boolean context will fail at runtime.</p> <p>Examples</p> <pre><code>class NotBoolable:\n__bool__ = None\nb1 = NotBoolable()\nb2 = NotBoolable()\nif b1:  # exception raised here\npass\nb1 and b2  # exception raised here\nnot b1  # exception raised here\nb1 &lt; b2 &lt; b1  # exception raised here\n</code></pre>"},{"location":"reference/rules/#unsupported-operator","title":"<code>unsupported-operator</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for binary expressions, comparisons, and unary expressions where the operands don't support the operator.</p> <p>Why is this bad?</p> <p>Attempting to use an unsupported operator will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A: ...\nA() + A()  # TypeError: unsupported operand type(s) for +: 'A' and 'A'\n</code></pre>"},{"location":"reference/rules/#zero-stepsize-in-slice","title":"<code>zero-stepsize-in-slice</code>","text":"<p> Default level: <code>error</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for step size 0 in slices.</p> <p>Why is this bad?</p> <p>A slice with a step size of zero will raise a <code>ValueError</code> at runtime.</p> <p>Examples</p> <pre><code>l = list(range(10))\nl[1:10:0]  # ValueError: slice step cannot be zero\n</code></pre>"},{"location":"reference/rules/#deprecated","title":"<code>deprecated</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for uses of deprecated items</p> <p>Why is this bad?</p> <p>Deprecated items should no longer be used.</p> <p>Examples</p> <pre><code>@warnings.deprecated(\"use new_func instead\")\ndef old_func(): ...\nold_func()  # emits [deprecated] diagnostic\n</code></pre>"},{"location":"reference/rules/#invalid-ignore-comment","title":"<code>invalid-ignore-comment</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for <code>type: ignore</code> and <code>ty: ignore</code> comments that are syntactically incorrect.</p> <p>Why is this bad?</p> <p>A syntactically incorrect ignore comment is probably a mistake and is useless.</p> <p>Examples</p> <pre><code>a = 20 / 0  # type: ignoree\n</code></pre> <p>Use instead:</p> <pre><code>a = 20 / 0  # type: ignore\n</code></pre>"},{"location":"reference/rules/#possibly-unbound-attribute","title":"<code>possibly-unbound-attribute</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for possibly unbound attributes.</p> <p>Why is this bad?</p> <p>Attempting to access an unbound attribute will raise an <code>AttributeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A:\nif b:\nc = 0\nA.c  # AttributeError: type object 'A' has no attribute 'c'\n</code></pre>"},{"location":"reference/rules/#possibly-unbound-implicit-call","title":"<code>possibly-unbound-implicit-call</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for implicit calls to possibly unbound methods.</p> <p>Why is this bad?</p> <p>Expressions such as <code>x[y]</code> and <code>x * y</code> call methods under the hood (<code>__getitem__</code> and <code>__mul__</code> respectively). Calling an unbound method will raise an <code>AttributeError</code> at runtime.</p> <p>Examples</p> <pre><code>import datetime\nclass A:\nif datetime.date.today().weekday() != 6:\ndef __getitem__(self, v): ...\nA()[0]  # TypeError: 'A' object is not subscriptable\n</code></pre>"},{"location":"reference/rules/#possibly-unbound-import","title":"<code>possibly-unbound-import</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for imports of symbols that may be unbound.</p> <p>Why is this bad?</p> <p>Importing an unbound module or name will raise a <code>ModuleNotFoundError</code> or <code>ImportError</code> at runtime.</p> <p>Examples</p> <pre><code># module.py\nimport datetime\nif datetime.date.today().weekday() != 6:\na = 1\n# main.py\nfrom module import a  # ImportError: cannot import name 'a' from 'module'\n</code></pre>"},{"location":"reference/rules/#redundant-cast","title":"<code>redundant-cast</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects redundant <code>cast</code> calls where the value already has the target type.</p> <p>Why is this bad?</p> <p>These casts have no effect and can be removed.</p> <p>Example</p> <pre><code>def f() -&gt; int:\nreturn 10\ncast(int, f())  # Redundant\n</code></pre>"},{"location":"reference/rules/#undefined-reveal","title":"<code>undefined-reveal</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls to <code>reveal_type</code> without importing it.</p> <p>Why is this bad?</p> <p>Using <code>reveal_type</code> without importing it will raise a <code>NameError</code> at runtime.</p> <p>Examples</p> <pre><code>reveal_type(1)  # NameError: name 'reveal_type' is not defined\n</code></pre>"},{"location":"reference/rules/#unknown-rule","title":"<code>unknown-rule</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for <code>ty: ignore[code]</code> where <code>code</code> isn't a known lint rule.</p> <p>Why is this bad?</p> <p>A <code>ty: ignore[code]</code> directive with a <code>code</code> that doesn't match any known rule will not suppress any type errors, and is probably a mistake.</p> <p>Examples</p> <pre><code>a = 20 / 0  # ty: ignore[division-by-zer]\n</code></pre> <p>Use instead:</p> <pre><code>a = 20 / 0  # ty: ignore[division-by-zero]\n</code></pre>"},{"location":"reference/rules/#unresolved-global","title":"<code>unresolved-global</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects variables declared as <code>global</code> in an inner scope that have no explicit bindings or declarations in the global scope.</p> <p>Why is this bad?</p> <p>Function bodies with <code>global</code> statements can run in any order (or not at all), which makes it hard for static analysis tools to infer the types of globals without explicit definitions or declarations.</p> <p>Example</p> <pre><code>def f():\nglobal x  # unresolved global\nx = 42\ndef g():\nprint(x)  # unresolved reference\n</code></pre> <p>Use instead: <pre><code>x: int\ndef f():\nglobal x\nx = 42\ndef g():\nprint(x)\n</code></pre></p> <p>Or: <pre><code>x: int | None = None\ndef f():\nglobal x\nx = 42\ndef g():\nprint(x)\n</code></pre></p>"},{"location":"reference/rules/#unsupported-base","title":"<code>unsupported-base</code>","text":"<p> Default level: <code>warn</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions that have bases which are unsupported by ty.</p> <p>Why is this bad?</p> <p>If a class has a base that is an instance of a complex type such as a union type, ty will not be able to resolve the method resolution order (MRO) for the class. This will lead to an inferior understanding of your codebase and unpredictable type-checking behavior.</p> <p>Examples</p> <pre><code>import datetime\nclass A: ...\nclass B: ...\nif datetime.date.today().weekday() != 6:\nC = A\nelse:\nC = B\nclass D(C): ...  # error: [unsupported-base]\n</code></pre>"},{"location":"reference/rules/#division-by-zero","title":"<code>division-by-zero</code>","text":"<p> Default level: <code>ignore</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>It detects division by zero.</p> <p>Why is this bad?</p> <p>Dividing by zero raises a <code>ZeroDivisionError</code> at runtime.</p> <p>Examples</p> <pre><code>5 / 0\n</code></pre>"},{"location":"reference/rules/#possibly-unresolved-reference","title":"<code>possibly-unresolved-reference</code>","text":"<p> Default level: <code>ignore</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for references to names that are possibly not defined.</p> <p>Why is this bad?</p> <p>Using an undefined variable will raise a <code>NameError</code> at runtime.</p> <p>Example</p> <pre><code>for i in range(0):\nx = i\nprint(x)  # NameError: name 'x' is not defined\n</code></pre>"},{"location":"reference/rules/#unused-ignore-comment","title":"<code>unused-ignore-comment</code>","text":"<p> Default level: <code>ignore</code> \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for <code>type: ignore</code> or <code>ty: ignore</code> directives that are no longer applicable.</p> <p>Why is this bad?</p> <p>A <code>type: ignore</code> directive that no longer matches any diagnostic violations is likely included by mistake, and should be removed to avoid confusion.</p> <p>Examples</p> <pre><code>a = 20 / 2  # ty: ignore[division-by-zero]\n</code></pre> <p>Use instead:</p> <pre><code>a = 20 / 2\n</code></pre>"}]}
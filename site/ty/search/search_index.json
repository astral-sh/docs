{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ty","text":"<p>An extremely fast Python type checker and language server, written in Rust.</p> <p> </p> <p> </p> <p> Type checking the home-assistant project without caching. </p> <p>ty is backed by Astral, the creators of uv and Ruff.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>10x - 100x faster than mypy and Pyright</li> <li>Comprehensive diagnostics with rich contextual information</li> <li>Configurable rule levels, per-file overrides, suppression comments, and first-class project support</li> <li>Designed for adoption, with support for redeclarations and partially typed code</li> <li>Language server with code navigation, completions, code actions, auto-import, inlay hints, on-hover help, etc.</li> <li>Fine-grained incremental analysis designed for fast updates when editing files in an IDE</li> <li>Editor integrations for VS Code, PyCharm, Neovim and more</li> <li>Advanced typing features like first-class intersection types, advanced type narrowing, and     sophisticated reachability analysis</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":"<p>Run ty with uvx to get started quickly:</p> <pre><code>uvx ty check\n</code></pre> <p>ty will check all Python files in the working directory or project by default.</p> <p>See the type checking documentation for more details.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install ty, see the installation documentation.</p> <p>To add the ty language server to your editor, see the editor integration guide.</p>"},{"location":"#playground","title":"Playground","text":"<p>ty has an online playground you can use to try it out on snippets or small projects.</p> <p>Tip</p> <p>The playground is a great way to share snippets with other people, e.g., when sharing a bug report.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#configuration-files","title":"Configuration files","text":"<p>ty supports persistent configuration files at both the project- and user-level.</p> <p>Specifically, ty will search for a <code>pyproject.toml</code> or <code>ty.toml</code> file in the current directory, or in the nearest parent directory.</p> <p>If a <code>pyproject.toml</code> file is found, ty will read configuration from the <code>[tool.ty]</code> table. For example, to ignore the <code>index-out-of-bounds</code> rule, add the following to a <code>pyproject.toml</code>:</p> pyproject.toml<pre><code>[tool.ty.rules]\nindex-out-of-bounds = \"ignore\"\n</code></pre> <p>Note</p> <p>If there is no <code>tool.ty</code> table, the <code>pyproject.toml</code> file will be ignored, and ty will continue searching in the directory hierarchy.</p> <p>ty will also search for <code>ty.toml</code> files, which follow an identical structure, but omit the <code>[tool.ty]</code> prefix. For example:</p> ty.toml<pre><code>[rules]\nindex-out-of-bounds = \"ignore\"\n</code></pre> <p>Important</p> <p><code>ty.toml</code> files take precedence over <code>pyproject.toml</code> files, so if both <code>ty.toml</code> and <code>pyproject.toml</code> files are present in a directory, configuration will be read from <code>ty.toml</code>, and the <code>[tool.ty]</code> section in the accompanying <code>pyproject.toml</code> will be ignored.</p> <p>ty will also discover user-level configuration at <code>~/.config/ty/ty.toml</code> (or <code>$XDG_CONFIG_HOME/ty/ty.toml</code>) on macOS and Linux, or <code>%APPDATA%\\ty\\ty.toml</code> on Windows. User-level configuration must use the <code>ty.toml</code> format, rather than the <code>pyproject.toml</code> format, as a <code>pyproject.toml</code> is intended to define a Python project.</p> <p>If project- and user-level configuration files are found, the settings will be merged, with project-level configuration taking precedence over the user-level configuration.</p> <p>For example, if a string, number, or boolean is present in both the project- and user-level configuration tables, the project-level value will be used, and the user-level value will be ignored. If an array is present in both tables, the arrays will be merged, with the project-level settings appearing later in the merged array.</p> <p>Settings provided via command line take precedence over persistent configuration.</p> <p>See the configuration reference for an enumeration of the available settings.</p>"},{"location":"editors/","title":"Editor integration","text":"<p>ty can be integrated with various editors to provide a seamless development experience.</p> <p>Learn more about ty's editor features in the language server documentation.</p>"},{"location":"editors/#vs-code","title":"VS Code","text":"<p>The Astral team maintains an official VS Code extension.</p> <p>Install the ty extension from the VS Code Marketplace.</p> <p>Then disable the language server from the Python extension by adding the following setting to your <code>settings.json</code> to avoid running two language servers:</p> <pre><code>{\n  \"python.languageServer\": \"None\"\n}\n</code></pre>"},{"location":"editors/#neovim","title":"Neovim","text":"<p>For Neovim 0.10 or earlier (with <code>nvim-lspconfig</code>):</p> <pre><code>require('lspconfig').ty.setup({\n  settings = {\n    ty = {\n      -- ty language server settings go here\n    }\n  }\n})\n</code></pre> <p>For Neovim 0.11+ (with <code>vim.lsp.config</code>):</p> <pre><code>-- Optional: Only required if you need to update the language server settings\nvim.lsp.config('ty', {\n  settings = {\n    ty = {\n      -- ty language server settings go here\n    }\n  }\n})\n\n-- Required: Enable the language server\nvim.lsp.enable('ty')\n</code></pre>"},{"location":"editors/#zed","title":"Zed","text":"<p>ty is included with Zed out of the box (no extension required), although the default primary LSP for Python is basedpyright.</p> <p>You can enable ty and disable basedpyright by adding this to your <code>settings.json</code> file:</p> <pre><code>{\n  \"languages\": {\n    \"Python\": {\n      \"language_servers\": [\n        // Disable basedpyright and enable Ty, and otherwise\n        // use the default configuration.\n        \"ty\",\n        \"!basedpyright\",\n        \"...\"\n      ]\n    }\n  }\n}\n</code></pre> <p>You can override the <code>ty</code> executable Zed uses by setting <code>lsp.ty.binary</code>:</p> <pre><code>{\n  \"lsp\": {\n    \"ty\": {\n      \"binary\": {\n        \"path\": \"/home/user/.local/bin/ty\",\n        \"arguments\": [\"server\"]\n      }\n    }\n  }\n}\n</code></pre> <p>More information in Zed's documentation.</p>"},{"location":"editors/#pycharm","title":"PyCharm","text":"<p>Starting with version 2025.3, PyCharm users can enable native ty support in the settings:</p> <ol> <li> <p>Go to Python | Tools | ty in the Settings dialog.</p> </li> <li> <p>Select the Enable checkbox.</p> </li> <li> <p>In the Execution mode setting, select how PyCharm should search for the executable:</p> <p>Interpreter mode: PyCharm searches for an executable installed in your interpreter. To install the ty package for the selected interpreter, click Install ty.</p> <p>Path mode: PyCharm searches for an executable in <code>$PATH</code>. If the executable is not found, you can specify the path by clicking the Browse... icon.</p> </li> <li> <p>Select which options should be enabled.</p> </li> </ol> <p>For more information, refer to PyCharm documentation.</p>"},{"location":"editors/#other-editors","title":"Other editors","text":"<p>ty can be used with any editor that supports the language server protocol.</p> <p>To start the language server, use the <code>server</code> subcommand:</p> <pre><code>ty server\n</code></pre> <p>Refer to your editor's documentation to learn how to connect to an LSP server.</p>"},{"location":"editors/#settings","title":"Settings","text":"<p>See the editor settings reference for more details on configuring the language server.</p>"},{"location":"exclusions/","title":"Excluding files","text":"<p>ty automatically discovers all Python files in your project. You can customize where ty searches by using the <code>src.include</code> and <code>src.exclude</code> settings.</p> <p>For example, with the following configuration, ty checks all Python files in the <code>src</code> and <code>tests</code> directories except those in the <code>src/generated</code> directory:</p> pyproject.toml<pre><code>[tool.ty.src]\ninclude = [\"src\", \"tests\"]\nexclude = [\"src/generated\"]\n</code></pre>"},{"location":"exclusions/#default-exclusions","title":"Default exclusions","text":"<p>By default, ty excludes a variety of commonly ignored directories. If you want to include one of these directories, you can do so by adding a negative <code>exclude</code> using a leading <code>!</code>:</p> pyproject.toml<pre><code>[tool.ty.src]\n# Remove `build` from the excluded directories.\nexclude = [\"!**/build/\"]\n</code></pre> <p>By default, ty ignores files listed in an <code>.ignore</code> or <code>.gitignore</code> file. To disable this functionality, set <code>respect-ignore-files</code> to <code>false</code>.</p>"},{"location":"exclusions/#explicit-targets","title":"Explicit targets","text":"<p>You may explicitly pass the paths that ty should check, e.g.:</p> <pre><code>ty check src scripts/benchmark.py\n</code></pre> <p>Paths that are passed as positional arguments to <code>ty check</code> are included even if they would otherwise be ignored through <code>exclude</code> filters or an ignore-file.</p>"},{"location":"exclusions/#include-and-exclude-syntax","title":"Include and exclude syntax","text":"<p>Both <code>include</code> and <code>exclude</code> support gitignore like glob patterns:</p> <ul> <li><code>src/</code> matches a directory (including its contents) named <code>src</code>.</li> <li><code>src</code> matches a file or directory (including its contents) named <code>src</code>.</li> <li><code>*</code> matches any (possibly empty) sequence of characters (except <code>/</code>).</li> <li><code>**</code> matches zero or more path components.     This sequence must form a single path component, so both <code>./**a</code> and <code>./b**/</code> are invalid and will result in an error.     A sequence of more than two consecutive <code>*</code> characters is also invalid.</li> <li><code>?</code> matches any single character except <code>/</code></li> <li><code>[abc]</code> matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode,     so e.g. <code>[0-9]</code> specifies any character between <code>0</code> and <code>9</code> inclusive. An unclosed bracket is invalid.</li> </ul> <p>All patterns are anchored: The pattern <code>src</code> only includes <code>&lt;project_root&gt;/src</code> but not something like <code>&lt;project_root&gt;/test/src</code>. To include any directory named <code>src</code>, use the prefix match <code>**/src</code>. The same applies for exclude patterns where <code>src</code> only excludes <code>&lt;project_root&gt;/src</code> but not something like <code>&lt;project_root&gt;/test/src</code>.</p> <p>Warning</p> <p>A prefix include pattern like <code>**/src</code> can notably slow down the Python file discovery.</p> <p>All fields accepting patterns use the reduced portable glob syntax from PEP 639, with the addition that characters can be escaped with a backslash.</p>"},{"location":"exclusions/#excluding-files-from-virtual-environments","title":"Excluding files from virtual environments","text":"<p>In Python 3.13+, the <code>venv</code> module will add a <code>.gitignore</code> file to the virtual environment root and ty will not emit diagnostics for the contained files. However, when using an older version of Python, ty may include diagnostics for files in the virtual environment.</p> <p>You can resolve this by adding a <code>.gitignore</code> to the environment, e.g., for a virtual environment named <code>.venv</code>:</p> <pre><code>echo \"*\" &gt; .venv/.gitignore\n</code></pre> <p>Or by adding your virtual environment to your <code>.gitignore</code> or <code>.ignore</code> file.</p>"},{"location":"installation/","title":"Installing ty","text":""},{"location":"installation/#running-ty-without-installation","title":"Running ty without installation","text":"<p>Use uvx to quickly get started with ty:</p> <pre><code>uvx ty\n</code></pre>"},{"location":"installation/#installation-methods","title":"Installation methods","text":""},{"location":"installation/#adding-ty-to-your-project","title":"Adding ty to your project","text":"<p>Tip</p> <p>Adding ty as a dependency ensures that all developers on the project are using the same version of ty.</p> <p>Use uv (or your project manager of choice) to add ty as a development dependency:</p> <pre><code>uv add --dev ty\n</code></pre> <p>Then, use <code>uv run</code> to invoke ty:</p> <pre><code>uv run ty\n</code></pre> <p>To update ty, use <code>--upgrade-package</code>:</p> <pre><code>uv lock --upgrade-package ty\n</code></pre>"},{"location":"installation/#installing-globally-with-uv","title":"Installing globally with uv","text":"<p>Install ty globally with uv:</p> <pre><code>uv tool install ty@latest\n</code></pre> <p>To update ty, use <code>uv tool upgrade</code>:</p> <pre><code>uv tool upgrade ty\n</code></pre>"},{"location":"installation/#installing-with-the-standalone-installer","title":"Installing with the standalone installer","text":"<p>ty includes a standalone installer.</p> macOS and LinuxWindows <p>Use <code>curl</code> to download the script and execute it with <code>sh</code>:</p> <pre><code>$ curl -LsSf https://astral.sh/ty/install.sh | sh\n</code></pre> <p>If your system doesn't have <code>curl</code>, you can use <code>wget</code>:</p> <pre><code>$ wget -qO- https://astral.sh/ty/install.sh | sh\n</code></pre> <p>Request a specific version by including it in the URL:</p> <pre><code>$ curl -LsSf https://astral.sh/ty/0.0.2/install.sh | sh\n</code></pre> <p>Use <code>irm</code> to download the script and execute it with <code>iex</code>:</p> <pre><code>PS&gt; powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/ty/install.ps1 | iex\"\n</code></pre> <p>Changing the execution policy allows running a script from the internet.</p> <p>Request a specific version by including it in the URL:</p> <pre><code>PS&gt; powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/ty/0.0.2/install.ps1 | iex\"\n</code></pre> <p>Tip</p> <p>The installation script may be inspected before use:</p> macOS and LinuxWindows <pre><code>$ curl -LsSf https://astral.sh/ty/install.sh | less\n</code></pre> <pre><code>PS&gt; powershell -c \"irm https://astral.sh/ty/install.ps1 | more\"\n</code></pre> <p>Alternatively, the installer or binaries can be downloaded directly from GitHub.</p>"},{"location":"installation/#installing-from-github-releases","title":"Installing from GitHub Releases","text":"<p>ty release artifacts can be downloaded directly from GitHub Releases.</p> <p>Each release page includes binaries for all supported platforms as well as instructions for using the standalone installer via <code>github.com</code> instead of <code>astral.sh</code>.</p>"},{"location":"installation/#installing-globally-with-pipx","title":"Installing globally with pipx","text":"<p>Install ty globally with pipx:</p> <pre><code>pipx install ty\n</code></pre> <p>To update ty, use <code>pipx upgrade</code>:</p> <pre><code>pipx upgrade ty\n</code></pre>"},{"location":"installation/#installing-with-pip","title":"Installing with pip","text":"<p>Install ty into your current Python environment with pip:</p> <pre><code>pip install ty\n</code></pre>"},{"location":"installation/#installing-in-docker","title":"Installing in Docker","text":"<p>Install ty in Docker by copying the binary from the official image:</p> Dockerfile<pre><code>COPY --from=ghcr.io/astral-sh/ty:latest /ty /bin/\n</code></pre> <p>The following tags are available:</p> <ul> <li><code>ghcr.io/astral-sh/ty:latest</code></li> <li><code>ghcr.io/astral-sh/ty:{major}.{minor}.{patch}</code>, e.g., <code>ghcr.io/astral-sh/ty:0.0.2</code></li> <li><code>ghcr.io/astral-sh/ty:{major}.{minor}</code>, e.g., <code>ghcr.io/astral-sh/ty:0.0</code> (the latest patch     version)</li> </ul>"},{"location":"installation/#adding-ty-to-your-editor","title":"Adding ty to your editor","text":"<p>See the editor integration guide to add ty to your editor.</p>"},{"location":"installation/#shell-autocompletion","title":"Shell autocompletion","text":"<p>Tip</p> <p>You can run <code>echo $SHELL</code> to help you determine your shell.</p> <p>To enable shell autocompletion for ty commands, run one of the following:</p> BashZshfishElvishPowerShell / pwsh <pre><code>echo 'eval \"$(ty generate-shell-completion bash)\"' &gt;&gt; ~/.bashrc\n</code></pre> <pre><code>echo 'eval \"$(ty generate-shell-completion zsh)\"' &gt;&gt; ~/.zshrc\n</code></pre> <pre><code>echo 'ty generate-shell-completion fish | source' &gt; ~/.config/fish/completions/ty.fish\n</code></pre> <pre><code>echo 'eval (ty generate-shell-completion elvish | slurp)' &gt;&gt; ~/.elvish/rc.elv\n</code></pre> <pre><code>if (!(Test-Path -Path $PROFILE)) {\n  New-Item -ItemType File -Path $PROFILE -Force\n}\nAdd-Content -Path $PROFILE -Value '(&amp; ty generate-shell-completion powershell) | Out-String | Invoke-Expression'\n</code></pre> <p>Then restart the shell or source the shell config file.</p>"},{"location":"modules/","title":"Module discovery","text":""},{"location":"modules/#first-party-modules","title":"First-party modules","text":"<p>First-party modules are Python files that are part of your project source code.</p> <p>By default, ty searches for first-party modules in the project's root directory or the <code>src</code> directory, if present.</p> <p>If your project uses a different layout, configure the project's <code>environment.root</code> in your <code>pyproject.toml</code> or <code>ty.toml</code>. For example, if your project's code is in an <code>app/</code> directory:</p> <pre><code>example-pkg\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 app\n    \u2514\u2500\u2500 example_pkg\n        \u2514\u2500\u2500 __init__.py\n</code></pre> <p>then set <code>environment.root</code> in your <code>pyproject.toml</code> to <code>[\"./app\"]</code>:</p> pyproject.toml<pre><code>[tool.ty.environment]\nroot = [\"./app\"]\n</code></pre> <p>Note that a <code>./python</code> folder is automatically added to the project <code>root</code> if it exists, and is not itself a package (i.e. does not contain an <code>__init__.py</code> file or an <code>__init__.pyi</code> file).</p>"},{"location":"modules/#third-party-modules","title":"Third-party modules","text":"<p>Third-party modules are Python packages that are not part of your project or the standard library. These are usually declared as dependencies in a <code>pyproject.toml</code> or <code>requirements.txt</code> file and installed using a package manager like uv or pip. Examples of popular third-party modules are <code>requests</code>, <code>numpy</code> and <code>django</code>.</p> <p>ty searches for third-party modules in the configured Python environment.</p>"},{"location":"modules/#python-environment","title":"Python environment","text":"<p>The Python environment is used for discovery of third-party modules.</p> <p>By default, ty will attempt to discover a virtual environment.</p> <p>First, ty checks for an active virtual environment using the <code>VIRTUAL_ENV</code> environment variable. If not set, ty will search for a <code>.venv</code> directory in the project root or working directory. ty only supports discovery of virtual environments at this time.</p> <p>Note</p> <p>When using project management tools, such as uv or Poetry, the <code>run</code> command usually automatically activates the virtual environment and will be detected by ty.</p> <p>The Python environment may be explicitly configured using the <code>environment.python</code> setting or <code>--python</code> flag.</p> <p>When setting the environment explicitly, non-virtual environments can be provided.</p>"},{"location":"python-version/","title":"Python version","text":"<p>The Python version affects allowed syntax, type definitions of the standard library, and type definitions of first- and third-party modules that are conditional on the Python version.</p> <p>For example, Python 3.10 introduced support for <code>match</code> statements and added the <code>sys.stdlib_module_names</code> symbol to the standard library. Syntactic features always need to be available in the lowest supported Python version, but symbols may be used in a <code>sys.version_info</code> conditional branch:</p> <pre><code>import sys\n\n# `invalid-syntax` error if `python-version` is set to 3.9 or lower:\nmatch \"echo hello\".split():\n    case [\"echo\", message]:\n        print(message)\n    case _:\n        print(\"unknown command\")\n\n# `unresolved-attribute` error if `python-version` is set to 3.9 or lower:\nprint(sys.stdlib_module_names)\n\nif sys.version_info &gt;= (3, 10):\n    # ok, because the usage is guarded by a version check:\n    print(sys.stdlib_module_names)\n</code></pre> <p>By default, the lower bound of the project's <code>requires-python</code> field (from the <code>pyproject.toml</code>) is used as the target Python version, ensuring that features and symbols only available in newer Python versions are not used.</p> <p>If the <code>requires-python</code> field is not available but a virtual environment has been configured or detected, ty will try to infer the Python version being used from the virtual environment's metadata.</p> <p>If no virtual environment is present or inferring the Python version from the metadata fails, ty will fall back to the latest stable Python version supported by ty (currently 3.14).</p> <p>The Python version may also be explicitly specified using the <code>python-version</code> setting or the <code>--python-version</code> flag.</p>"},{"location":"rules/","title":"Rules","text":"<p>Rules are individual checks that ty performs to detect common issues in your code, such as incompatible assignments, missing imports, or invalid type annotations. Each rule focuses on a specific pattern and can be turned on or off depending on your project\u2019s needs.</p> <p>Tip</p> <p>See the rules reference for an enumeration of all supported rules.</p>"},{"location":"rules/#rule-levels","title":"Rule levels","text":"<p>Each rule has a configurable level:</p> <ul> <li><code>error</code>: violations are reported as errors and ty exits with an exit code of 1 if there's any.</li> <li><code>warn</code>: violations are reported as warnings. Depending on your configuration, ty exits with an exit code of 0 if there are only warning violations (default) or 1 when using <code>--error-on-warning</code>.</li> <li><code>ignore</code>: the rule is turned off</li> </ul> <p>You can configure the level for each rule on the command line using the <code>--warn</code>, <code>--error</code>, and <code>--ignore</code> flags. For example:</p> <pre><code>ty check \\\n  --warn unused-ignore-comment \\        # Make `unused-ignore-comment` a warning\n  --ignore redundant-cast \\             # Disable `redundant-cast`\n  --error possibly-missing-attribute \\  # Error on `possibly-missing-attribute`\n  --error possibly-missing-import       # Error on `possibly-missing-import`\n</code></pre> <p>The options can be repeated. Subsequent options override earlier options.</p> <p>Rule levels can also be changed in the <code>rules</code> section of a configuration file.</p> <p>For example, the following is equivalent to the command above:</p> pyproject.toml<pre><code>[tool.ty.rules]\nunused-ignore-comment = \"warn\"\nredundant-cast = \"ignore\"\npossibly-missing-attribute = \"error\"\npossibly-missing-import = \"error\"\n</code></pre>"},{"location":"suppression/","title":"Suppression","text":"<p>Rules can also be ignored in specific locations in your code (instead of disabling the rule entirely) to silence false positives or permissible violations.</p> <p>Note</p> <p>To disable a rule entirely, set it to the <code>ignore</code> level as described in rule levels.</p>"},{"location":"suppression/#ty-suppression-comments","title":"ty suppression comments","text":"<p>To suppress a rule violation inline add a <code># ty: ignore[&lt;rule&gt;]</code> comment at the end of the line:</p> <pre><code>a = 10 + \"test\"  # ty: ignore[unsupported-operator]\n</code></pre> <p>Rule violations spanning multiple lines can be suppressed by adding the comment at the end of the violation's first or last line:</p> <pre><code>def sum_three_numbers(a: int, b: int, c: int) -&gt; int: ...\n\n# on the first line\n\nsum_three_numbers(  # ty: ignore[missing-argument]\n    3,\n    2\n)\n\n# or, on the last line\n\nsum_three_numbers(\n    3,\n    2\n)  # ty: ignore[missing-argument]\n</code></pre> <p>To suppress multiple violations on a single line, enumerate each rule separated by a comma:</p> <pre><code>sum_three_numbers(\"one\", 5)  # ty: ignore[missing-argument, invalid-argument-type]\n</code></pre> <p>Note</p> <p>Enumerating rule names (e.g., <code>[rule1, rule2]</code>) is optional. However, we strongly recommend including suppressing specific rules to avoid accidental suppression of other errors.</p>"},{"location":"suppression/#standard-suppression-comments","title":"Standard suppression comments","text":"<p>ty supports the standard <code>type: ignore</code> comment format introduced by PEP 484.</p> <p>ty handles these similarly to <code>ty: ignore</code> comments, but suppresses all violations on that line, even when <code>type: ignore[code]</code> is used.</p> <pre><code># Ignore all typing errors on the next line\nsum_three_numbers(\"one\", 5)  # type: ignore\n</code></pre>"},{"location":"suppression/#multiple-suppressions-comments","title":"Multiple suppressions comments","text":"<p>To suppress a typing error on a line that already has a suppression comment from another tool, add the <code># ty: ignore</code> comment to the same line.</p> <p>For example, to suppress a type error and disable formatting for a specific line:</p> <pre><code>result = calculate()  # ty: ignore[invalid-argument-type]  # fmt: skip\n\n# or\nresult = calculate()  # fmt: off  # ty: ignore[invalid-argument-type]\n</code></pre>"},{"location":"suppression/#unused-suppression-comments","title":"Unused suppression comments","text":"<p>If the <code>unused-ignore-comment</code> rule is enabled, ty will report unused <code>ty: ignore</code> and <code>type: ignore</code> comments.</p> <p><code>unused-ignore-comment</code> violations can only be suppressed using <code># ty: ignore[unused-ignore-comment]</code>. They cannot be suppressed using <code># ty: ignore</code> without a rule code or <code># type: ignore</code>.</p>"},{"location":"suppression/#no_type_check-directive","title":"<code>@no_type_check</code> directive","text":"<p>ty supports the <code>@no_type_check</code> decorator to suppress all violations inside a function.</p> <pre><code>from typing import no_type_check\n\ndef sum_three_numbers(a: int, b: int, c: int) -&gt; int:\n    return a + b + c\n\n@no_type_check\ndef main():\n    sum_three_numbers(1, 2)  # no error for the missing argument\n</code></pre> <p>Decorating a class with <code>@no_type_check</code> isn't supported.</p>"},{"location":"type-checking/","title":"Type checking","text":"<p>After installing ty, it's time to type check some code!</p>"},{"location":"type-checking/#running-the-type-checker","title":"Running the type checker","text":"<p>To run the type checker, use the <code>check</code> command:</p> <pre><code>ty check\n</code></pre> <p>Tip</p> <p>If you're in a project, you may need to use <code>uv run</code> or activate your virtual environment first for ty to find your dependencies.</p>"},{"location":"type-checking/#environment-discovery","title":"Environment discovery","text":"<p>The type checker needs to discover your installed packages in order to check your use of imported dependencies.</p> <p>ty will find installed packages in the active virtual environment (via <code>VIRTUAL_ENV</code>) or discover a virtual environment named <code>.venv</code> in the project root or working directory. It will not find packages in non-virtual environments without specifying the target path with <code>--python</code>.</p> <p>See the module discovery documentation for details.</p>"},{"location":"type-checking/#file-selection","title":"File selection","text":"<p>ty will run on all Python files in the working directory (including subdirectories, recursively). If used from a project, ty will run on all Python files in the project (starting in the directory with the <code>pyproject.toml</code>).</p> <p>You can also provide specific paths to check:</p> <pre><code>ty check example.py\n</code></pre> <p>You can also persistently configure included and excluded files.</p>"},{"location":"type-checking/#rule-selection-and-severity","title":"Rule selection and severity","text":"<p>ty's type checking diagnostics are often associated with a rule.</p> <p>ty's type checking rules can be configured to your project's needs. See the rules documentation for details.</p> <p>You can also suppress specific violations of rules using suppression comments.</p>"},{"location":"type-checking/#watch-mode","title":"Watch mode","text":"<p>ty can be run in an incremental watch mode:</p> <pre><code>ty check --watch\n</code></pre> <p>ty will watch files for changes and recheck any affected files \u2014 including files that depend on the changed file. ty uses fine-grained incrementality to perform subsequent checks much faster than running <code>ty check</code> repeatedly.</p>"},{"location":"type-checking/#the-type-system","title":"The type system","text":"<p>To learn more about what makes type checking in ty unique, read about the type system.</p>"},{"location":"features/diagnostics/","title":"Diagnostics","text":"<p>ty provides diagnostics that include snippets of your source code, annotations and helpful explanations. It will sometimes also provide suggestions on how to fix the reported issues.</p>"},{"location":"features/diagnostics/#example-typed-dictionaries","title":"Example: Typed dictionaries","text":"<p>In this first example, ty detected an invalid assignment to a <code>TypedDict</code> key. Notice how the diagnostic includes both the context around the line with the error, as well as the reference to the <code>age</code> item in the <code>TypedDict</code> definition:</p> <p> </p> <p>When a <code>TypedDict</code> key is misspelled, ty will suggest the correct spelling. If you are using an editor with language server support, you can also apply this suggestion as a quick fix:</p> <p> </p>"},{"location":"features/diagnostics/#example-invalid-arguments","title":"Example: Invalid arguments","text":"<p>Here, a file has been opened for writing in text mode, but we are trying to write bytes to it. The diagnostic points out the type mismatch and also includes the corresponding parameter in the function definition for <code>write</code>:</p> <p> </p>"},{"location":"features/diagnostics/#example-backwards-compatibility","title":"Example: Backwards compatibility","text":"<p>Instead of just telling you that <code>tomllib</code> can not be found, ty will tell you why it is not available for your project. In this case, your project is targeting Python 3.10, but <code>tomllib</code> was only added in Python 3.11:</p> <p> </p>"},{"location":"features/language-server/","title":"Language server","text":""},{"location":"features/language-server/#language-server","title":"Language server","text":"<p>You can generally expect ty to be a fully-featured language server for Python. This page describes some of the key features provided by ty's IDE integration and includes a reference table of supported LSP features at the end. See the editor integration guide for instructions on how to set up ty with your editor.</p>"},{"location":"features/language-server/#diagnostics","title":"Diagnostics","text":"Example of an inline diagnostic with code-span annotations <p>ty reports type errors and other diagnostics directly in your editor. Diagnostics are updated as you type. You can use the <code>diagnosticMode</code> setting to control if you want to see diagnostics for open files only, or for your entire workspace.</p> <p>Info</p> <p>ty supports both the \"pull\" and \"push\" diagnostic models. Most modern editors will use the \"pull\" model for better performance, where diagnostics are fetched on demand rather than pushed after every change.</p>"},{"location":"features/language-server/#code-navigation","title":"Code navigation","text":"\"Find references\" shows usages across the entire workspace <p>ty powers several language server features that allow you to navigate a Python codebase:</p> <ul> <li>Go to Definition: Jump to where a symbol is defined. ty resolves imports, function calls,     class references, and more.</li> <li>Go to Declaration: Navigate to the declaration site of a symbol, which can differ from its     definition (could be in a stub file).</li> <li>Go to Type Definition: Navigate to the type of a symbol. For example, this takes you to the class <code>Person</code>     when invoked on a variable <code>user: Person</code>.</li> <li>Find all references: Find every usage of a function, class, or variable across your entire workspace.</li> <li>Document and workspace symbols: See an outline of symbols in the current file, or search through symbols across your entire workspace.</li> </ul>"},{"location":"features/language-server/#code-completions","title":"Code completions","text":"Accepting this completion will automatically add a <code>subprocess</code> import at the top of the file. <p>ty provides intelligent code completions as you type, offering suggestions for variables, functions, classes, and modules that are in scope. For symbols that are not yet imported, ty suggests auto-import actions to add the necessary <code>import</code> statements.</p>"},{"location":"features/language-server/#code-actions-and-refactorings","title":"Code actions and refactorings","text":"ty offers to remove the unused suppression comment <p>ty offers quick fixes and other code actions to help you resolve issues:</p> <ul> <li>Add import: Automatically add missing import statements</li> <li>Quick fixes: Some diagnostics come with quick fix suggestions to resolve the issue</li> <li>Rename symbol: Safely rename symbols across your entire codebase</li> <li>Selection range: Expand or shrink the text selection in your editor based on ty's understanding of Python syntax</li> </ul>"},{"location":"features/language-server/#contextual-information","title":"Contextual information","text":"Gray inlay hints and on-hover information (signature, docstring) <p>ty surfaces useful contextual information as you code:</p> <ul> <li>Hover: Hover over any symbol to see its type, documentation, function signatures, and other     useful information like the variance of type parameters.</li> <li>Inlay hints: Display inline type hints for variables and parameters without explicit     annotations, as well as parameter names at call sites. These hints can also be double-clicked     to insert the type annotations into your source code. You can also click on parts of the inlay     hints for go-to-definition navigation.</li> <li>Signature help: When calling a function, ty displays the function's parameters and their     types. This appears automatically when you type <code>(</code> and updates as you navigate between arguments.</li> <li>Document highlight: When the cursor is on a symbol, ty highlights all occurrences of that     symbol in the current file.</li> <li>Semantic highlighting: Syntax highlighting based on the underlying semantics and types.</li> </ul>"},{"location":"features/language-server/#notebook-support","title":"Notebook support","text":"<p>ty supports Jupyter notebooks (<code>.ipynb</code> files) with language server features. Each cell is analyzed in context, with diagnostics, completions, and other features working across cells.</p>"},{"location":"features/language-server/#fine-grained-incrementality","title":"Fine-grained incrementality","text":"<p>ty's architecture is designed for low-latency updates of diagnostics and other language server features. When you make a change in your editor, ty incrementally updates only the affected parts of the codebase, rather than re-analyzing everything from scratch. This happens at a fine-grained level, down to individual definitions. This incrementality means that you get instant feedback as you type, i.e., within a few milliseconds, even on large projects.</p> <p>Info</p> <p>Fine-grained dependencies also allow ty to skip large parts of 3rd-party dependencies when they are not relevant to your codebase.</p>"},{"location":"features/language-server/#feature-reference","title":"Feature reference","text":"Feature Status Notes <code>callHierarchy/*</code> \u274c Not supported <code>notebookDocument/*</code> \u2705 Supported <code>textDocument/codeAction</code> \u2705 Supported Quick fixes <code>textDocument/codeLens</code> \u274c Not supported <code>textDocument/completion</code> \u2705 Supported <code>textDocument/declaration</code> \u2705 Supported <code>textDocument/definition</code> \u2705 Supported <code>textDocument/diagnostic</code> \u2705 Supported <code>textDocument/documentColor</code> \u274c Not supported <code>textDocument/documentHighlight</code> \u2705 Supported <code>textDocument/documentLink</code> \u274c Not supported <code>textDocument/documentSymbol</code> \u2705 Supported <code>textDocument/foldingRange</code> \u274c Not supported <code>textDocument/formatting</code> \u2014 Use Ruff for formatting <code>textDocument/hover</code> \u2705 Supported <code>textDocument/implementation</code> \u274c Not supported <code>textDocument/inlayHint</code> \u2705 Supported <code>textDocument/onTypeFormatting</code> \u2014 Ruff #16829 <code>textDocument/prepareRename</code> \u2705 Supported <code>textDocument/rangeFormatting</code> \u2014 Use Ruff for formatting <code>textDocument/references</code> \u2705 Supported <code>textDocument/rename</code> \u2705 Supported <code>textDocument/selectionRange</code> \u2705 Supported <code>textDocument/semanticTokens</code> \u2705 Supported <code>textDocument/signatureHelp</code> \u2705 Supported <code>textDocument/typeDefinition</code> \u2705 Supported <code>typeHierarchy/*</code> \u274c Not supported #534 <code>workspace/diagnostic</code> \u2705 Supported <code>workspace/symbol</code> \u2705 Supported <code>workspace/willRenameFiles</code> \u274c Not supported #1560"},{"location":"features/type-system/","title":"Type system","text":"<p>You can generally expect ty to support all typing features that are described and specified in the Python typing documentation (for a detailed overview, please refer to the type system features tracking issue). This page highlights some of the unique features that ty's type system provides.</p>"},{"location":"features/type-system/#redeclarations","title":"Redeclarations","text":"<p>ty allows you to reuse the same symbol with a different type. The following example shows how the <code>paths</code> parameter is redeclared as a list of strings:</p> <pre><code>def split_paths(paths: str) -&gt; list[Path]:\n    paths: list[str] = paths.split(\":\")\n    return [Path(p) for p in paths]\n</code></pre> <p>(Full example in the playground)</p>"},{"location":"features/type-system/#intersection-types","title":"Intersection types","text":"<p>ty has first-class support for intersection types. In contrast to a union type <code>A | B</code>, which means \"either A or B\", an intersection type <code>A &amp; B</code> means \"both A and B\". Type narrowing in ty is based on intersections. For example, notice how we can call <code>obj.serialize_json()</code> and access the <code>.version</code> property in the following function:</p> <pre><code>def output_as_json(obj: Serializable) -&gt; str:\n    if isinstance(obj, Versioned):\n        reveal_type(obj)  # reveals: Serializable &amp; Versioned\n\n        return str({\n            \"data\": obj.serialize_json(),\n            \"version\": obj.version\n        })\n    else:\n        return obj.serialize_json()\n</code></pre> <p>(Full example in the playground)</p> <p>Intersections can also be built using gradual types like <code>Any</code> or its implicit counterpart <code>Unknown</code>. For example, imagine you call into untyped (third party) code that returns an object of type <code>Unknown</code>. Narrowing the type of that object using <code>isinstance</code> will result in an intersection type <code>Unknown &amp; Iterable</code>. This type allows you to use <code>obj</code> as an iterable. But more importantly, it still gives you access to attributes defined on the original unknown type (<code>.description</code>, in this example):</p> <pre><code>def print_content(data: bytes):\n    obj = untyped_library.deserialize(data)\n\n    if isinstance(obj, Iterable):\n        print(obj.description)\n        for part in obj:\n            print(\"*\", part.description)\n    else:\n        print(obj.description)\n</code></pre> <p>(Full example in the playground)</p> <p>Intersection types are also used in <code>hasattr</code> narrowing. Take a look at the following example where we narrow a type of <code>Person | Animal | None</code> using <code>hasattr(\u2026, \"name\")</code>. <code>Person</code> is preserved in the narrowed union type because it has a <code>name</code> attribute. <code>Animal</code> is intersected with a synthetic protocol, accounting for the possibility of subclasses of <code>Animal</code> that add a <code>name</code> member. <code>None</code> is excluded completely since it is a final type that has no <code>name</code> attribute:</p> <pre><code>class Person:\n    name: str\n\nclass Animal:\n    species: str\n\ndef greet(being: Person | Animal | None):\n    if hasattr(being, \"name\"):\n        # `being` is now of type `Person | (Animal &amp; &lt;Protocol with members 'name'&gt;)`\n\n        print(f\"Hello, {being.name}!\")\n    else:\n        print(\"Hello there!\")\n</code></pre> <p>(Full example in the playground)</p> <p>Info</p> <p>If you run into a situation like this and would like <code>Animal</code> to be excluded from the narrowed type as well, you can make <code>Animal</code> a <code>@final</code> class. This also allows ty to infer a more precise type for <code>being.name</code> (<code>str</code> instead of <code>object</code>).</p> <p>If ty is the only type checker you use, you can also make direct use of intersection types in annotations by importing <code>Intersection</code> from the special <code>ty_extensions</code> module that is (currently) only available at type-checking time:</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from ty_extensions import Intersection\n\n    type SerializableVersioned = Intersection[Serializable, Versioned]\n\ndef output_as_json(obj: SerializableVersioned) -&gt; str:\n    ...\n</code></pre> <p>(Full example in the playground)</p>"},{"location":"features/type-system/#top-and-bottom-materializations","title":"Top and bottom materializations","text":"<p>Gradual types generally have two special materializations. The top materialization represents the \"largest\" type that a gradual type can materialize to: the union of all possible materializations. For example, the top materialization of <code>Any</code> is <code>object</code>, and the top materialization of <code>Any &amp; int</code> is <code>int</code>. For invariant generic classes, the top materialization cannot be expressed in Python's type system, but it is a useful type that ty intersects with when <code>isinstance</code> checks involve generic classes. For example, when checking <code>isinstance(\u2026, list)</code>, ty intersects with the top materialization of <code>list[Unknown]</code>:</p> <pre><code>@final\nclass Item: ...\n\ndef process(items: Item | list[Item]):\n    if isinstance(items, list):\n        # reveals: list[Item]\n        reveal_type(items)\n</code></pre> <p>(Full example in the playground)</p> <p>Info</p> <p>You might wonder why <code>Item</code> is declared <code>@final</code> here. If we remove the <code>@final</code> decorator, the inferred type in the <code>if</code> branch becomes <code>(Item &amp; Top[list[Unknown]]) | list[Item]</code> instead. This accounts for the possibility of classes that inherit from both <code>Item</code> and <code>list</code>! If you run into this situation and want to rule out this case, you can also perform the <code>isinstance</code> check against <code>Item</code> instead. The <code>else</code> branch will then have a narrowed type of <code>list[Item] &amp; ~Item</code>, which effectively acts like <code>list[Item]</code>.</p>"},{"location":"features/type-system/#reachability-based-on-types","title":"Reachability based on types","text":"<p>Reachability analysis in ty is based on type inference. This allows ty to detect unreachable branches in many more situations compared to approaches which match on a few known patterns (e.g. <code>sys.version_info &gt;= (3, 10)</code> checks). This has useful practical applications. Consider a case where you are writing code that needs to be compatible with two major versions of a dependency. The following code can be successfully type-checked with either pydantic 1.x installed, or pydantic 2.x installed. In both cases, ty will only consider the corresponding branch to be reachable, and will not emit any type errors for the other branch. This works because <code>pydantic.__version__.startswith(\"2.\")</code> can be evaluated to <code>True</code> or <code>False</code> at type-checking time:</p> <pre><code>import pydantic\nfrom pydantic import BaseModel\n\nPYDANTIC_V2 = pydantic.__version__.startswith(\"2.\")\n\nclass Person(BaseModel):\n    name: str\n\ndef to_json(person: Person):\n    if PYDANTIC_V2:\n        return person.model_dump_json()  # no error here when checking with 1.x\n    else:\n        return person.json()\n</code></pre> <p>(Full example in the playground)</p>"},{"location":"features/type-system/#gradual-guarantee","title":"Gradual guarantee","text":"<p>ty generally tries to avoid emitting false positive type errors in untyped code. The following snippet does not produce any type errors when checked with ty (whereas other type checkers make the assumption that <code>max_retries</code> is of type <code>None</code>, leading to an error in the attribute assignment):</p> <pre><code>class RetryPolicy:\n    max_retries = None\n\npolicy = RetryPolicy()\npolicy.max_retries = 1\n</code></pre> <p>(Full example in the playground)</p> <p>This is achieved by treating <code>max_retries</code> as being of type <code>Unknown | None</code>, which means that the type of the attribute is not fully known, but <code>None</code> is definitely a possible value.</p> <p>Users can always opt into stricter checking by adding type annotations (<code>int | None</code>, in this case).</p> <p>Info</p> <p>We are also planning to add a mode for users that prefer to have stricter types inferred by default in these situations. You can follow this issue for updates.</p>"},{"location":"features/type-system/#fixpoint-iteration","title":"Fixpoint iteration","text":"<p>In a situation where a symbol's type cyclically depends on itself, ty uses a mechanism called fixpoint iteration to be able to infer a type for that symbol. In the <code>tick</code> method below, note how the type of <code>self.value</code> depends on <code>self.value</code> itself. ty starts by assuming that <code>self.value</code> is just <code>Unknown | Literal[0]</code> (the type inferred from the <code>__init__</code> method), and then iterates until the type converges to <code>Unknown | Literal[0, 1, 2, 3, 4]</code>. Without the modulo operation, the union would grow indefinitely. In that case, we fall back to <code>int</code> after a certain number of iterations.</p> <pre><code>class LoopingCounter:\n    def __init__(self):\n        self.value = 0\n\n    def tick(self):\n        self.value = (self.value + 1) % 5\n\n# reveals: Unknown | Literal[0, 1, 2, 3, 4]\nreveal_type(LoopingCounter().value)\n</code></pre> <p>(Full example in the playground)</p>"},{"location":"reference/cli/","title":"CLI","text":""},{"location":"reference/cli/#cli-reference","title":"CLI Reference","text":""},{"location":"reference/cli/#ty","title":"ty","text":"<p>An extremely fast Python type checker.</p> Usage <pre><code>ty &lt;COMMAND&gt;\n</code></pre> Commands <code>ty check</code><p>Check a project for type errors</p> <code>ty server</code><p>Start the language server</p> <code>ty version</code><p>Display ty's version</p> <code>ty help</code><p>Print this message or the help of the given subcommand(s)</p>"},{"location":"reference/cli/#ty-check","title":"ty check","text":"<p>Check a project for type errors</p> Usage <pre><code>ty check [OPTIONS] [PATH]...\n</code></pre> Arguments <code>PATHS</code><p>List of files or directories to check [default: the project root]</p> Options <code>--color</code> when<p>Control when colored output is used</p> <p>Possible values:</p> <ul> <li><code>auto</code>:  Display colors if the output goes to an interactive terminal</li> <li><code>always</code>:  Always display colors</li> <li><code>never</code>:  Never display colors</li> </ul><code>--config</code>, <code>-c</code> config-option<p>A TOML <code>&lt;KEY&gt; = &lt;VALUE&gt;</code> pair (such as you might find in a <code>ty.toml</code> configuration file) overriding a specific configuration option.</p> <p>Overrides of individual settings using this option always take precedence over all configuration files.</p> <code>--config-file</code> path<p>The path to a <code>ty.toml</code> file to use for configuration.</p> <p>While ty configuration can be included in a <code>pyproject.toml</code> file, it is not allowed in this context.</p> <p>May also be set with the <code>TY_CONFIG_FILE</code> environment variable.</p><code>--error</code> rule<p>Treat the given rule as having severity 'error'. Can be specified multiple times.</p> <code>--error-on-warning</code><p>Use exit code 1 if there are any warning-level diagnostics</p> <code>--exclude</code> exclude<p>Glob patterns for files to exclude from type checking.</p> <p>Uses gitignore-style syntax to exclude files and directories from type checking. Supports patterns like <code>tests/</code>, <code>*.tmp</code>, <code>**/__pycache__/**</code>.</p> <code>--exit-zero</code><p>Always use exit code 0, even when there are error-level diagnostics</p> <code>--extra-search-path</code> path<p>Additional path to use as a module-resolution source (can be passed multiple times).</p> <p>This is an advanced option that should usually only be used for first-party or third-party modules that are not installed into your Python environment in a conventional way. Use <code>--python</code> to point ty to your Python environment if it is in an unusual location.</p> <code>--help</code>, <code>-h</code><p>Print help (see a summary with '-h')</p> <code>--ignore</code> rule<p>Disables the rule. Can be specified multiple times.</p> <code>--no-progress</code><p>Hide all progress outputs.</p> <p>For example, spinners or progress bars.</p> <code>--output-format</code> output-format<p>The format to use for printing diagnostic messages</p> <p>Possible values:</p> <ul> <li><code>full</code>:  Print diagnostics verbosely, with context and helpful hints (default)</li> <li><code>concise</code>:  Print diagnostics concisely, one per line</li> <li><code>gitlab</code>:  Print diagnostics in the JSON format expected by GitLab Code Quality reports</li> <li><code>github</code>:  Print diagnostics in the format used by GitHub Actions workflow error annotations</li> </ul><code>--project</code> project<p>Run the command within the given project directory.</p> <p>All <code>pyproject.toml</code> files will be discovered by walking up the directory tree from the given project directory, as will the project's virtual environment (<code>.venv</code>) unless the <code>venv-path</code> option is set.</p> <p>Other command-line arguments (such as relative paths) will be resolved relative to the current working directory.</p> <code>--python</code>, <code>--venv</code> path<p>Path to your project's Python environment or interpreter.</p> <p>ty uses your Python environment to resolve third-party imports in your code.</p> <p>If you're using a project management tool such as uv or you have an activated Conda or virtual environment, you should not generally need to specify this option.</p> <p>This option can be used to point to virtual or system Python environments.</p> <code>--python-platform</code>, <code>--platform</code> platform<p>Target platform to assume when resolving types.</p> <p>This is used to specialize the type of <code>sys.platform</code> and will affect the visibility of platform-specific functions and attributes. If the value is set to <code>all</code>, no assumptions are made about the target platform. If unspecified, the current system's platform will be used.</p> <code>--python-version</code>, <code>--target-version</code> version<p>Python version to assume when resolving types.</p> <p>The Python version affects allowed syntax, type definitions of the standard library, and type definitions of first- and third-party modules that are conditional on the Python version.</p> <p>If a version is not specified on the command line or in a configuration file, ty will try the following techniques in order of preference to determine a value: 1. Check for the <code>project.requires-python</code> setting in a <code>pyproject.toml</code> file and use the minimum version from the specified range 2. Check for an activated or configured Python environment and attempt to infer the Python version of that environment 3. Fall back to the latest stable Python version supported by ty (see <code>ty check --help</code> output)</p> <p>Possible values:</p> <ul> <li><code>3.7</code></li> <li><code>3.8</code></li> <li><code>3.9</code></li> <li><code>3.10</code></li> <li><code>3.11</code></li> <li><code>3.12</code></li> <li><code>3.13</code></li> <li><code>3.14</code></li> </ul><code>--quiet</code>, <code>-q</code><p>Use quiet output (or <code>-qq</code> for silent output)</p> <code>--respect-ignore-files</code><p>Respect file exclusions via <code>.gitignore</code> and other standard ignore files. Use <code>--no-respect-gitignore</code> to disable</p> <code>--typeshed</code>, <code>--custom-typeshed-dir</code> path<p>Custom directory to use for stdlib typeshed stubs</p> <code>--verbose</code>, <code>-v</code><p>Use verbose output (or <code>-vv</code> and <code>-vvv</code> for more verbose output)</p> <code>--warn</code> rule<p>Treat the given rule as having severity 'warn'. Can be specified multiple times.</p> <code>--watch</code>, <code>-W</code><p>Watch files for changes and recheck files related to the changed files</p>"},{"location":"reference/cli/#ty-server","title":"ty server","text":"<p>Start the language server</p> Usage <pre><code>ty server\n</code></pre> Options <code>--help</code>, <code>-h</code><p>Print help</p>"},{"location":"reference/cli/#ty-version","title":"ty version","text":"<p>Display ty's version</p> Usage <pre><code>ty version\n</code></pre> Options <code>--help</code>, <code>-h</code><p>Print help</p>"},{"location":"reference/cli/#ty-generate-shell-completion","title":"ty generate-shell-completion","text":"<p>Generate shell completion</p> Usage <pre><code>ty generate-shell-completion &lt;SHELL&gt;\n</code></pre> Arguments <code>SHELL</code> Options <code>--help</code>, <code>-h</code><p>Print help</p>"},{"location":"reference/cli/#ty-help","title":"ty help","text":"<p>Print this message or the help of the given subcommand(s)</p> Usage <pre><code>ty help [COMMAND]\n</code></pre>"},{"location":"reference/configuration/","title":"Configuration","text":""},{"location":"reference/configuration/#configuration","title":"Configuration","text":""},{"location":"reference/configuration/#rules","title":"<code>rules</code>","text":"<p>Configures the enabled rules and their severity.</p> <p>See the rules documentation for a list of all available rules.</p> <p>Valid severities are:</p> <ul> <li><code>ignore</code>: Disable the rule.</li> <li><code>warn</code>: Enable the rule and create a warning diagnostic.</li> <li><code>error</code>: Enable the rule and create an error diagnostic.   ty will exit with a non-zero code if any error diagnostics are emitted.</li> </ul> <p>Default value: <code>{...}</code></p> <p>Type: <code>dict[RuleName, \"ignore\" | \"warn\" | \"error\"]</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.rules]\npossibly-unresolved-reference = \"warn\"\ndivision-by-zero = \"ignore\"\n</code></pre>"},{"location":"reference/configuration/#environment","title":"<code>environment</code>","text":""},{"location":"reference/configuration/#extra-paths","title":"<code>extra-paths</code>","text":"<p>User-provided paths that should take first priority in module resolution.</p> <p>This is an advanced option that should usually only be used for first-party or third-party modules that are not installed into your Python environment in a conventional way. Use the <code>python</code> option to specify the location of your Python environment.</p> <p>This option is similar to mypy's <code>MYPYPATH</code> environment variable and pyright's <code>stubPath</code> configuration setting.</p> <p>Default value: <code>[]</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.environment]\nextra-paths = [\"./shared/my-search-path\"]\n</code></pre>"},{"location":"reference/configuration/#python","title":"<code>python</code>","text":"<p>Path to your project's Python environment or interpreter.</p> <p>ty uses the <code>site-packages</code> directory of your project's Python environment to resolve third-party (and, in some cases, first-party) imports in your code.</p> <p>If you're using a project management tool such as uv, you should not generally need to specify this option, as commands such as <code>uv run</code> will set the <code>VIRTUAL_ENV</code> environment variable to point to your project's virtual environment. ty can also infer the location of your environment from an activated Conda environment, and will look for a <code>.venv</code> directory in the project root if none of the above apply.</p> <p>Passing a path to a Python executable is supported, but passing a path to a dynamic executable (such as a shim) is not currently supported.</p> <p>This option can be used to point to virtual or system Python environments.</p> <p>Default value: <code>null</code></p> <p>Type: <code>str</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.environment]\npython = \"./custom-venv-location/.venv\"\n</code></pre>"},{"location":"reference/configuration/#python-platform","title":"<code>python-platform</code>","text":"<p>Specifies the target platform that will be used to analyze the source code. If specified, ty will understand conditions based on comparisons with <code>sys.platform</code>, such as are commonly found in typeshed to reflect the differing contents of the standard library across platforms. If <code>all</code> is specified, ty will assume that the source code can run on any platform.</p> <p>If no platform is specified, ty will use the current platform: - <code>win32</code> for Windows - <code>darwin</code> for macOS - <code>android</code> for Android - <code>ios</code> for iOS - <code>linux</code> for everything else</p> <p>Default value: <code>&lt;current-platform&gt;</code></p> <p>Type: <code>\"win32\" | \"darwin\" | \"android\" | \"ios\" | \"linux\" | \"all\" | str</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.environment]\n# Tailor type stubs and conditionalized type definitions to windows.\npython-platform = \"win32\"\n</code></pre>"},{"location":"reference/configuration/#python-version","title":"<code>python-version</code>","text":"<p>Specifies the version of Python that will be used to analyze the source code. The version should be specified as a string in the format <code>M.m</code> where <code>M</code> is the major version and <code>m</code> is the minor (e.g. <code>\"3.0\"</code> or <code>\"3.6\"</code>). If a version is provided, ty will generate errors if the source code makes use of language features that are not supported in that version.</p> <p>If a version is not specified, ty will try the following techniques in order of preference to determine a value: 1. Check for the <code>project.requires-python</code> setting in a <code>pyproject.toml</code> file    and use the minimum version from the specified range 2. Check for an activated or configured Python environment    and attempt to infer the Python version of that environment 3. Fall back to the default value (see below)</p> <p>For some language features, ty can also understand conditionals based on comparisons with <code>sys.version_info</code>. These are commonly found in typeshed, for example, to reflect the differing contents of the standard library across Python versions.</p> <p>Default value: <code>\"3.14\"</code></p> <p>Type: <code>\"3.7\" | \"3.8\" | \"3.9\" | \"3.10\" | \"3.11\" | \"3.12\" | \"3.13\" | \"3.14\" | &lt;major&gt;.&lt;minor&gt;</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.environment]\npython-version = \"3.12\"\n</code></pre>"},{"location":"reference/configuration/#root","title":"<code>root</code>","text":"<p>The root paths of the project, used for finding first-party modules.</p> <p>Accepts a list of directory paths searched in priority order (first has highest priority).</p> <p>If left unspecified, ty will try to detect common project layouts and initialize <code>root</code> accordingly:</p> <ul> <li>if a <code>./src</code> directory exists, include <code>.</code> and <code>./src</code> in the first party search path (src layout or flat)</li> <li>if a <code>./&lt;project-name&gt;/&lt;project-name&gt;</code> directory exists, include <code>.</code> and <code>./&lt;project-name&gt;</code> in the first party search path</li> <li>otherwise, default to <code>.</code> (flat layout)</li> </ul> <p>Additionally, if a <code>./python</code> directory exists and is not a package (i.e. it does not contain an <code>__init__.py</code> or <code>__init__.pyi</code> file), it will also be included in the first party search path.</p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.environment]\n# Multiple directories (priority order)\nroot = [\"./src\", \"./lib\", \"./vendor\"]\n</code></pre>"},{"location":"reference/configuration/#typeshed","title":"<code>typeshed</code>","text":"<p>Optional path to a \"typeshed\" directory on disk for us to use for standard-library types. If this is not provided, we will fallback to our vendored typeshed stubs for the stdlib, bundled as a zip file in the binary</p> <p>Default value: <code>null</code></p> <p>Type: <code>str</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.environment]\ntypeshed = \"/path/to/custom/typeshed\"\n</code></pre>"},{"location":"reference/configuration/#overrides","title":"<code>overrides</code>","text":"<p>Configuration override that applies to specific files based on glob patterns.</p> <p>An override allows you to apply different rule configurations to specific files or directories. Multiple overrides can match the same file, with later overrides take precedence. Override rules take precedence over global rules for matching files.</p> <p>For example, to relax enforcement of rules in test files:</p> <pre><code>[[tool.ty.overrides]]\ninclude = [\"tests/**\", \"**/test_*.py\"]\n\n[tool.ty.overrides.rules]\npossibly-unresolved-reference = \"warn\"\n</code></pre> <p>Or, to ignore a rule in generated files but retain enforcement in an important file:</p> <pre><code>[[tool.ty.overrides]]\ninclude = [\"generated/**\"]\nexclude = [\"generated/important.py\"]\n\n[tool.ty.overrides.rules]\npossibly-unresolved-reference = \"ignore\"\n</code></pre>"},{"location":"reference/configuration/#exclude","title":"<code>exclude</code>","text":"<p>A list of file and directory patterns to exclude from this override.</p> <p>Patterns follow a syntax similar to <code>.gitignore</code>. Exclude patterns take precedence over include patterns within the same override.</p> <p>If not specified, defaults to <code>[]</code> (excludes no files).</p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[[tool.ty.overrides]]\nexclude = [\n    \"generated\",\n    \"*.proto\",\n    \"tests/fixtures/**\",\n    \"!tests/fixtures/important.py\"  # Include this one file\n]\n</code></pre>"},{"location":"reference/configuration/#include","title":"<code>include</code>","text":"<p>A list of file and directory patterns to include for this override.</p> <p>The <code>include</code> option follows a similar syntax to <code>.gitignore</code> but reversed: Including a file or directory will make it so that it (and its contents) are affected by this override.</p> <p>If not specified, defaults to <code>[\"**\"]</code> (matches all files).</p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[[tool.ty.overrides]]\ninclude = [\n    \"src\",\n    \"tests\",\n]\n</code></pre>"},{"location":"reference/configuration/#rules_1","title":"<code>rules</code>","text":"<p>Rule overrides for files matching the include/exclude patterns.</p> <p>These rules will be merged with the global rules, with override rules taking precedence for matching files. You can set rules to different severity levels or disable them entirely.</p> <p>Default value: <code>{...}</code></p> <p>Type: <code>dict[RuleName, \"ignore\" | \"warn\" | \"error\"]</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[[tool.ty.overrides]]\ninclude = [\"src\"]\n\n[tool.ty.overrides.rules]\npossibly-unresolved-reference = \"ignore\"\n</code></pre>"},{"location":"reference/configuration/#src","title":"<code>src</code>","text":""},{"location":"reference/configuration/#exclude_1","title":"<code>exclude</code>","text":"<p>A list of file and directory patterns to exclude from type checking.</p> <p>Patterns follow a syntax similar to <code>.gitignore</code>:</p> <ul> <li><code>./src/</code> matches only a directory</li> <li><code>./src</code> matches both files and directories</li> <li><code>src</code> matches files or directories named <code>src</code></li> <li><code>*</code> matches any (possibly empty) sequence of characters (except <code>/</code>).</li> <li><code>**</code> matches zero or more path components.   This sequence must form a single path component, so both <code>**a</code> and <code>b**</code> are invalid and will result in an error.   A sequence of more than two consecutive <code>*</code> characters is also invalid.</li> <li><code>?</code> matches any single character except <code>/</code></li> <li><code>[abc]</code> matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode,   so e.g. <code>[0-9]</code> specifies any character between <code>0</code> and <code>9</code> inclusive. An unclosed bracket is invalid.</li> <li><code>!pattern</code> negates a pattern (undoes the exclusion of files that would otherwise be excluded)</li> </ul> <p>All paths are anchored relative to the project root (<code>src</code> only matches <code>&lt;project_root&gt;/src</code> and not <code>&lt;project_root&gt;/test/src</code>). To exclude any directory or file named <code>src</code>, use <code>**/src</code> instead.</p> <p>By default, ty excludes commonly ignored directories:</p> <ul> <li><code>**/.bzr/</code></li> <li><code>**/.direnv/</code></li> <li><code>**/.eggs/</code></li> <li><code>**/.git/</code></li> <li><code>**/.git-rewrite/</code></li> <li><code>**/.hg/</code></li> <li><code>**/.mypy_cache/</code></li> <li><code>**/.nox/</code></li> <li><code>**/.pants.d/</code></li> <li><code>**/.pytype/</code></li> <li><code>**/.ruff_cache/</code></li> <li><code>**/.svn/</code></li> <li><code>**/.tox/</code></li> <li><code>**/.venv/</code></li> <li><code>**/__pypackages__/</code></li> <li><code>**/_build/</code></li> <li><code>**/buck-out/</code></li> <li><code>**/dist/</code></li> <li><code>**/node_modules/</code></li> <li><code>**/venv/</code></li> </ul> <p>You can override any default exclude by using a negated pattern. For example, to re-include <code>dist</code> use <code>exclude = [\"!dist\"]</code></p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.src]\nexclude = [\n    \"generated\",\n    \"*.proto\",\n    \"tests/fixtures/**\",\n    \"!tests/fixtures/important.py\"  # Include this one file\n]\n</code></pre>"},{"location":"reference/configuration/#include_1","title":"<code>include</code>","text":"<p>A list of files and directories to check. The <code>include</code> option follows a similar syntax to <code>.gitignore</code> but reversed: Including a file or directory will make it so that it (and its contents) are type checked.</p> <ul> <li><code>./src/</code> matches only a directory</li> <li><code>./src</code> matches both files and directories</li> <li><code>src</code> matches a file or directory named <code>src</code></li> <li><code>*</code> matches any (possibly empty) sequence of characters (except <code>/</code>).</li> <li><code>**</code> matches zero or more path components.   This sequence must form a single path component, so both <code>**a</code> and <code>b**</code> are invalid and will result in an error.   A sequence of more than two consecutive <code>*</code> characters is also invalid.</li> <li><code>?</code> matches any single character except <code>/</code></li> <li><code>[abc]</code> matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode,   so e.g. <code>[0-9]</code> specifies any character between <code>0</code> and <code>9</code> inclusive. An unclosed bracket is invalid.</li> </ul> <p>All paths are anchored relative to the project root (<code>src</code> only matches <code>&lt;project_root&gt;/src</code> and not <code>&lt;project_root&gt;/test/src</code>).</p> <p><code>exclude</code> takes precedence over <code>include</code>.</p> <p>Default value: <code>null</code></p> <p>Type: <code>list[str]</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.src]\ninclude = [\n    \"src\",\n    \"tests\",\n]\n</code></pre>"},{"location":"reference/configuration/#respect-ignore-files","title":"<code>respect-ignore-files</code>","text":"<p>Whether to automatically exclude files that are ignored by <code>.ignore</code>, <code>.gitignore</code>, <code>.git/info/exclude</code>, and global <code>gitignore</code> files. Enabled by default.</p> <p>Default value: <code>true</code></p> <p>Type: <code>bool</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.src]\nrespect-ignore-files = false\n</code></pre>"},{"location":"reference/configuration/#root_1","title":"<code>root</code>","text":"<p>Deprecated</p> <p>This option has been deprecated. Use <code>environment.root</code> instead.</p> <p>The root of the project, used for finding first-party modules.</p> <p>If left unspecified, ty will try to detect common project layouts and initialize <code>src.root</code> accordingly:</p> <ul> <li>if a <code>./src</code> directory exists, include <code>.</code> and <code>./src</code> in the first party search path (src layout or flat)</li> <li>if a <code>./&lt;project-name&gt;/&lt;project-name&gt;</code> directory exists, include <code>.</code> and <code>./&lt;project-name&gt;</code> in the first party search path</li> <li>otherwise, default to <code>.</code> (flat layout)</li> </ul> <p>Additionally, if a <code>./python</code> directory exists and is not a package (i.e. it does not contain an <code>__init__.py</code> file), it will also be included in the first party search path.</p> <p>Default value: <code>null</code></p> <p>Type: <code>str</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.src]\nroot = \"./app\"\n</code></pre>"},{"location":"reference/configuration/#terminal","title":"<code>terminal</code>","text":""},{"location":"reference/configuration/#error-on-warning","title":"<code>error-on-warning</code>","text":"<p>Use exit code 1 if there are any warning-level diagnostics.</p> <p>Defaults to <code>false</code>.</p> <p>Default value: <code>false</code></p> <p>Type: <code>bool</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.terminal]\n# Error if ty emits any warning-level diagnostics.\nerror-on-warning = true\n</code></pre>"},{"location":"reference/configuration/#output-format","title":"<code>output-format</code>","text":"<p>The format to use for printing diagnostic messages.</p> <p>Defaults to <code>full</code>.</p> <p>Default value: <code>full</code></p> <p>Type: <code>full | concise</code></p> <p>Example usage:</p> pyproject.toml<pre><code>[tool.ty.terminal]\noutput-format = \"concise\"\n</code></pre>"},{"location":"reference/editor-settings/","title":"Editor settings","text":"<p>The editor settings supported by ty's language server, as well as the settings specific to ty's VS Code extension.</p>"},{"location":"reference/editor-settings/#disablelanguageservices","title":"<code>disableLanguageServices</code>","text":"<p>Whether to disable the language services for the ty language server like code completion, hover, go to definition, etc.</p> <p>This is useful if you want to use ty exclusively for type checking and want to use another language server for features like code completion, hover, go to definition, etc.</p> <p>Default value: <code>false</code></p> <p>Type: <code>boolean</code></p> <p>Example usage:</p> VS CodeNeovimZed <pre><code>{\n  \"ty.disableLanguageServices\": true\n}\n</code></pre> <pre><code>require('lspconfig').ty.setup({\n  settings = {\n    ty = {\n      disableLanguageServices = true,\n    },\n  },\n})\n\n-- For Neovim 0.11.0 and later:\nvim.lsp.config('ty', {\n  settings = {\n    ty = {\n      disableLanguageServices = true,\n    },\n  },\n})\n</code></pre> <pre><code>{\n  \"lsp\": {\n    \"ty\": {\n      \"settings\": {\n        \"disableLanguageServices\": true\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/editor-settings/#diagnosticmode","title":"<code>diagnosticMode</code>","text":"<p>Determines the scope of the diagnostics reported by the language server.</p> <ul> <li><code>openFilesOnly</code>: Diagnostics are reported only for files that are currently open in the editor.</li> <li><code>workspace</code>: Diagnostics are reported for all files in the workspace.</li> </ul> <p>Default value: <code>\"openFilesOnly\"</code></p> <p>Type: <code>\"workspace\" | \"openFilesOnly\"</code></p> <p>Example usage:</p> VS CodeNeovimZed <pre><code>{\n  \"ty.diagnosticMode\": \"workspace\"\n}\n</code></pre> <pre><code>require('lspconfig').ty.setup({\n  settings = {\n    ty = {\n      diagnosticMode = 'workspace',\n    },\n  },\n})\n\n-- For Neovim 0.11.0 and later:\nvim.lsp.config('ty', {\n  settings = {\n    ty = {\n      diagnosticMode = 'workspace',\n    },\n  },\n})\n</code></pre> <pre><code>{\n  \"lsp\": {\n    \"ty\": {\n      \"settings\": {\n        \"diagnosticMode\": \"workspace\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/editor-settings/#inlayhints","title":"<code>inlayHints</code>","text":"<p>These settings control the inline hints that ty provides in an editor.</p>"},{"location":"reference/editor-settings/#variabletypes","title":"<code>variableTypes</code>","text":"<p>Whether to show the types of variables as inline hints.</p> <p>Default value: <code>true</code></p> <p>Type: <code>boolean</code></p> <p>Example usage:</p> VS CodeNeovimZed <pre><code>{\n  \"ty.inlayHints.variableTypes\": false\n}\n</code></pre> <pre><code>require('lspconfig').ty.setup({\n  settings = {\n    ty = {\n      inlayHints = {\n        variableTypes = false,\n      },\n    },\n  },\n})\n\n-- For Neovim 0.11.0 and later:\nvim.lsp.config('ty', {\n  settings = {\n    ty = {\n      inlayHints = {\n        variableTypes = false,\n      },\n    },\n  },\n})\n</code></pre> <pre><code>{\n  \"lsp\": {\n    \"ty\": {\n      \"settings\": {\n        \"inlayHints\": {\n          \"variableTypes\": false\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/editor-settings/#callargumentnames","title":"<code>callArgumentNames</code>","text":"<p>Whether to show argument names in call expressions as inline hints.</p> <p>Default value: <code>true</code></p> <p>Type: <code>boolean</code></p> <p>Example usage:</p> VS CodeNeovimZed <pre><code>{\n  \"ty.inlayHints.callArgumentNames\": false\n}\n</code></pre> <pre><code>require('lspconfig').ty.setup({\n  settings = {\n    ty = {\n      inlayHints = {\n        callArgumentNames = false,\n      },\n    },\n  },\n})\n\n-- For Neovim 0.11.0 and later:\nvim.lsp.config('ty', {\n  settings = {\n    ty = {\n      inlayHints = {\n        callArgumentNames = false,\n      },\n    },\n  },\n})\n</code></pre> <pre><code>{\n  \"lsp\": {\n    \"ty\": {\n      \"settings\": {\n        \"inlayHints\": {\n          \"callArgumentNames\": false\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/editor-settings/#completions","title":"<code>completions</code>","text":"<p>These settings control how code completions offered by ty work.</p>"},{"location":"reference/editor-settings/#autoimport","title":"<code>autoImport</code>","text":"<p>Whether to include auto-import suggestions in code completions. That is, code completions will include symbols not currently in scope but available in your environment.</p> <p>Default value: <code>true</code></p> <p>Type: <code>boolean</code></p> <p>Example usage:</p> VS CodeNeovimZed <pre><code>{\n  \"ty.completions.autoImport\": true\n}\n</code></pre> <pre><code>require('lspconfig').ty.setup({\n  settings = {\n    ty = {\n      completions = {\n        autoImport = true,\n      },\n    },\n  },\n})\n\n-- For Neovim 0.11.0 and later:\nvim.lsp.config('ty', {\n  settings = {\n    ty = {\n      completions = {\n        autoImport = true,\n      },\n    },\n  },\n})\n</code></pre> <pre><code>{\n  \"lsp\": {\n    \"ty\": {\n      \"settings\": {\n        \"completions\": {\n          \"autoImport\": true\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/editor-settings/#vs-code-specific","title":"VS Code specific","text":"<p>The following settings are specific to ty's VS Code extension.</p>"},{"location":"reference/editor-settings/#importstrategy","title":"<code>importStrategy</code>","text":"<p>Strategy for loading the <code>ty</code> executable.</p> <ul> <li><code>fromEnvironment</code> finds ty in the environment, falling back to the bundled version</li> <li><code>useBundled</code> uses the version bundled with the extension</li> </ul> <p>Default value: <code>\"fromEnvironment\"</code></p> <p>Type: <code>\"fromEnvironment\" | \"useBundled\"</code></p> <p>Example usage:</p> <pre><code>{\n  \"ty.importStrategy\": \"useBundled\"\n}\n</code></pre>"},{"location":"reference/editor-settings/#interpreter","title":"<code>interpreter</code>","text":"<p>A list of paths to Python interpreters. Even though this is a list, only the first interpreter is used.</p> <p>The interpreter path is used to find the <code>ty</code> executable when <code>ty.importStrategy</code> is set to <code>fromEnvironment</code>.</p> <p>Default value: <code>[]</code></p> <p>Type: <code>string[]</code></p> <p>Example usage:</p> <pre><code>{\n  \"ty.interpreter\": [\"/home/user/.local/bin/python\"]\n}\n</code></pre>"},{"location":"reference/editor-settings/#path","title":"<code>path</code>","text":"<p>A list of path to <code>ty</code> executables.</p> <p>The extension uses the first executable that exists. This setting takes precedence over the <code>ty.importStrategy</code> setting.</p> <p>Default value: <code>[]</code></p> <p>Type: <code>string[]</code></p> <p>Example usage:</p> <pre><code>{\n  \"ty.path\": [\"/home/user/.local/bin/ty\"]\n}\n</code></pre>"},{"location":"reference/editor-settings/#traceserver","title":"<code>trace.server</code>","text":"<p>The detail level at which messages between the language server and the editor (client) are logged.</p> <p>This setting is useful for debugging issues with the language server. Refer to the troubleshooting guide in ty's VS Code extension for more information.</p> <p>Default value: <code>\"off\"</code></p> <p>Type: <code>\"off\" | \"messages\" | \"verbose\"</code></p> <p>Example usage:</p> <pre><code>{\n  \"ty.trace.server\": \"messages\"\n}\n</code></pre>"},{"location":"reference/editor-settings/#initialization-options","title":"Initialization options","text":"<p>The following settings are required when ty is initialized in an editor. These settings are static so changing them requires restarting the editor to take effect.</p> <p>For VS Code users, these settings are defined in the <code>ty.*</code> namespace as usual, but for other editors, they would need to be provided in a separate field of the configuration that corresponds to the initialization options. Refer to the examples below for how to set these options in different editors.</p>"},{"location":"reference/editor-settings/#logfile","title":"<code>logFile</code>","text":"<p>Path to the file to which the language server writes its log messages. By default, ty writes log messages to stderr.</p> <p>Default value: <code>null</code></p> <p>Type: <code>string</code></p> <p>Example usage:</p> VS CodeNeovimZed <pre><code>{\n  \"ty.logFile\": \"/path/to/ty.log\"\n}\n</code></pre> <pre><code>require('lspconfig').ty.setup({\n  init_options = {\n    logFile = '/path/to/ty.log',\n  },\n})\n\n-- For Neovim 0.11.0 and later:\nvim.lsp.config('ty', {\n  init_options = {\n    logFile = '/path/to/ty.log',\n  },\n})\n</code></pre> <pre><code>{\n  \"lsp\": {\n    \"ty\": {\n      \"initialization_options\": {\n        \"logFile\": \"/path/to/ty.log\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/editor-settings/#loglevel","title":"<code>logLevel</code>","text":"<p>The log level to use for the language server.</p> <p>Default value: <code>\"info\"</code></p> <p>Type: <code>\"trace\" | \"debug\" | \"info\" | \"warn\" | \"error\"</code></p> <p>Example usage:</p> VS CodeNeovimZed <pre><code>{\n  \"ty.logLevel\": \"debug\"\n}\n</code></pre> <pre><code>require('lspconfig').ty.setup({\n  init_options = {\n    logLevel = 'debug',\n  },\n})\n\n-- For Neovim 0.11.0 and later:\nvim.lsp.config('ty', {\n  init_options = {\n    logLevel = 'debug',\n  },\n})\n</code></pre> <pre><code>{\n  \"lsp\": {\n    \"ty\": {\n      \"initialization_options\": {\n        \"logLevel\": \"debug\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/environment/","title":"Environment variables","text":"<p>ty defines and respects the following environment variables:</p>"},{"location":"reference/environment/#ty_config_file","title":"<code>TY_CONFIG_FILE</code>","text":"<p>Path to a <code>ty.toml</code> configuration file to use.</p> <p>When set, ty will use this file for configuration instead of discovering configuration files automatically.</p> <p>Equivalent to the <code>--config-file</code> command-line argument.</p>"},{"location":"reference/environment/#ty_log","title":"<code>TY_LOG</code>","text":"<p>If set, ty will use this value as the log level for its <code>--verbose</code> output. Accepts any filter compatible with the <code>tracing_subscriber</code> crate.</p> <p>For example:</p> <ul> <li><code>TY_LOG=uv=debug</code> is the equivalent of <code>-vv</code> to the command line</li> <li><code>TY_LOG=trace</code> will enable all trace-level logging.</li> </ul> <p>See the tracing documentation for more.</p>"},{"location":"reference/environment/#ty_log_profile","title":"<code>TY_LOG_PROFILE</code>","text":"<p>If set to <code>\"1\"</code> or <code>\"true\"</code>, ty will enable flamegraph profiling. This creates a <code>tracing.folded</code> file that can be used to generate flame graphs for performance analysis.</p>"},{"location":"reference/environment/#ty_max_parallelism","title":"<code>TY_MAX_PARALLELISM</code>","text":"<p>Specifies an upper limit for the number of tasks ty is allowed to run in parallel.</p> <p>For example, how many files should be checked in parallel. This isn't the same as a thread limit. ty may spawn additional threads when necessary, e.g. to watch for file system changes or a dedicated UI thread.</p>"},{"location":"reference/environment/#externally-defined-variables","title":"Externally-defined variables","text":"<p>ty also reads the following externally defined environment variables:</p>"},{"location":"reference/environment/#conda_default_env","title":"<code>CONDA_DEFAULT_ENV</code>","text":"<p>Used to determine the name of the active Conda environment.</p>"},{"location":"reference/environment/#conda_prefix","title":"<code>CONDA_PREFIX</code>","text":"<p>Used to detect the path of an active Conda environment. If both <code>VIRTUAL_ENV</code> and <code>CONDA_PREFIX</code> are present, <code>VIRTUAL_ENV</code> will be preferred.</p>"},{"location":"reference/environment/#pythonpath","title":"<code>PYTHONPATH</code>","text":"<p>Adds additional directories to ty's search paths. The format is the same as the shell\u2019s PATH: one or more directory pathnames separated by os appropriate pathsep (e.g. colons on Unix or semicolons on Windows).</p>"},{"location":"reference/environment/#rayon_num_threads","title":"<code>RAYON_NUM_THREADS</code>","text":"<p>Specifies an upper limit for the number of threads ty uses when performing work in parallel. Equivalent to <code>TY_MAX_PARALLELISM</code>.</p> <p>This is a standard Rayon environment variable.</p>"},{"location":"reference/environment/#virtual_env","title":"<code>VIRTUAL_ENV</code>","text":"<p>Used to detect an activated virtual environment.</p>"},{"location":"reference/environment/#xdg_config_home","title":"<code>XDG_CONFIG_HOME</code>","text":"<p>Path to user-level configuration directory on Unix systems.</p>"},{"location":"reference/environment/#_conda_root","title":"<code>_CONDA_ROOT</code>","text":"<p>Used to determine the root install path of Conda.</p>"},{"location":"reference/exit-codes/","title":"Exit codes","text":"<p>The ty command line interface uses the following exit codes:</p> Exit code Description <code>0</code> no violations with severity <code>error</code> or higher were found <code>1</code> violations with severity <code>error</code> or higher were found <code>2</code> invalid CLI options, invalid configuration, or IO errors <code>101</code> internal error <p>ty supports two command line arguments that change how exit codes work:</p> <ul> <li><code>--exit-zero</code>: ty will exit with <code>0</code> even if violations were found.</li> <li><code>--error-on-warning</code>: ty will exit with <code>1</code> if it finds any violations with severity <code>warning</code> or     higher.</li> </ul>"},{"location":"reference/rules/","title":"Rules","text":""},{"location":"reference/rules/#rules","title":"Rules","text":""},{"location":"reference/rules/#byte-string-type-annotation","title":"<code>byte-string-type-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for byte-strings in type annotation positions.</p> <p>Why is this bad?</p> <p>Static analysis tools like ty can't analyze type annotations that use byte-string notation.</p> <p>Examples</p> <pre><code>def test(): -&gt; b\"int\":\n    ...\n</code></pre> <p>Use instead: <pre><code>def test(): -&gt; \"int\":\n    ...\n</code></pre></p>"},{"location":"reference/rules/#call-non-callable","title":"<code>call-non-callable</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls to non-callable objects.</p> <p>Why is this bad?</p> <p>Calling a non-callable object will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>4()  # TypeError: 'int' object is not callable\n</code></pre>"},{"location":"reference/rules/#conflicting-argument-forms","title":"<code>conflicting-argument-forms</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks whether an argument is used as both a value and a type form in a call.</p> <p>Why is this bad?</p> <p>Such calls have confusing semantics and often indicate a logic error.</p> <p>Examples</p> <pre><code>from typing import reveal_type\nfrom ty_extensions import is_singleton\n\nif flag:\n    f = repr  # Expects a value\nelse:\n    f = is_singleton  # Expects a type form\n\nf(int)  # error\n</code></pre>"},{"location":"reference/rules/#conflicting-declarations","title":"<code>conflicting-declarations</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks whether a variable has been declared as two conflicting types.</p> <p>Why is this bad</p> <p>A variable with two conflicting declarations likely indicates a mistake. Moreover, it could lead to incorrect or ill-defined type inference for other code that relies on these variables.</p> <p>Examples</p> <pre><code>if b:\n    a: int\nelse:\n    a: str\n\na = 1\n</code></pre>"},{"location":"reference/rules/#conflicting-metaclass","title":"<code>conflicting-metaclass</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions where the metaclass of the class being created would not be a subclass of the metaclasses of all the class's bases.</p> <p>Why is it bad?</p> <p>Such a class definition raises a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class M1(type): ...\nclass M2(type): ...\nclass A(metaclass=M1): ...\nclass B(metaclass=M2): ...\n\n# TypeError: metaclass conflict\nclass C(A, B): ...\n</code></pre>"},{"location":"reference/rules/#cyclic-class-definition","title":"<code>cyclic-class-definition</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions in stub files that inherit (directly or indirectly) from themselves.</p> <p>Why is it bad?</p> <p>Although forward references are natively supported in stub files, inheritance cycles are still disallowed, as it is impossible to resolve a consistent method resolution order for a class that inherits from itself.</p> <p>Examples</p> <pre><code># foo.pyi\nclass A(B): ...\nclass B(A): ...\n</code></pre>"},{"location":"reference/rules/#cyclic-type-alias-definition","title":"<code>cyclic-type-alias-definition</code>","text":"<p> Default level: <code>error</code> \u00b7 Preview (since 1.0.0) \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for type alias definitions that (directly or mutually) refer to themselves.</p> <p>Why is it bad?</p> <p>Although it is permitted to define a recursive type alias, it is not meaningful to have a type alias whose expansion can only result in itself, and is therefore not allowed.</p> <p>Examples</p> <pre><code>type Itself = Itself\n\ntype A = B\ntype B = A\n</code></pre>"},{"location":"reference/rules/#duplicate-base","title":"<code>duplicate-base</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions with duplicate bases.</p> <p>Why is this bad?</p> <p>Class definitions with duplicate bases raise <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A: ...\n\n# TypeError: duplicate base class\nclass B(A, A): ...\n</code></pre>"},{"location":"reference/rules/#duplicate-kw-only","title":"<code>duplicate-kw-only</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.12 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for dataclass definitions with more than one field annotated with <code>KW_ONLY</code>.</p> <p>Why is this bad?</p> <p><code>dataclasses.KW_ONLY</code> is a special marker used to emulate the <code>*</code> syntax in normal signatures. It can only be used once per dataclass.</p> <p>Attempting to annotate two different fields with it will lead to a runtime error.</p> <p>Examples</p> <pre><code>from dataclasses import dataclass, KW_ONLY\n\n@dataclass\nclass A:  # Crash at runtime\n    b: int\n    _1: KW_ONLY\n    c: str\n    _2: KW_ONLY\n    d: bytes\n</code></pre>"},{"location":"reference/rules/#escape-character-in-forward-annotation","title":"<code>escape-character-in-forward-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>TODO #14889</p>"},{"location":"reference/rules/#fstring-type-annotation","title":"<code>fstring-type-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for f-strings in type annotation positions.</p> <p>Why is this bad?</p> <p>Static analysis tools like ty can't analyze type annotations that use f-string notation.</p> <p>Examples</p> <pre><code>def test(): -&gt; f\"int\":\n    ...\n</code></pre> <p>Use instead: <pre><code>def test(): -&gt; \"int\":\n    ...\n</code></pre></p>"},{"location":"reference/rules/#implicit-concatenated-string-type-annotation","title":"<code>implicit-concatenated-string-type-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for implicit concatenated strings in type annotation positions.</p> <p>Why is this bad?</p> <p>Static analysis tools like ty can't analyze type annotations that use implicit concatenated strings.</p> <p>Examples</p> <pre><code>def test(): -&gt; \"Literal[\" \"5\" \"]\":\n    ...\n</code></pre> <p>Use instead: <pre><code>def test(): -&gt; \"Literal[5]\":\n    ...\n</code></pre></p>"},{"location":"reference/rules/#inconsistent-mro","title":"<code>inconsistent-mro</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for classes with an inconsistent method resolution order (MRO).</p> <p>Why is this bad?</p> <p>Classes with an inconsistent MRO will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A: ...\nclass B(A): ...\n\n# TypeError: Cannot create a consistent method resolution order\nclass C(A, B): ...\n</code></pre>"},{"location":"reference/rules/#index-out-of-bounds","title":"<code>index-out-of-bounds</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for attempts to use an out of bounds index to get an item from a container.</p> <p>Why is this bad?</p> <p>Using an out of bounds index will raise an <code>IndexError</code> at runtime.</p> <p>Examples</p> <pre><code>t = (0, 1, 2)\nt[3]  # IndexError: tuple index out of range\n</code></pre>"},{"location":"reference/rules/#instance-layout-conflict","title":"<code>instance-layout-conflict</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.12 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for classes definitions which will fail at runtime due to \"instance memory layout conflicts\".</p> <p>This error is usually caused by attempting to combine multiple classes that define non-empty <code>__slots__</code> in a class's Method Resolution Order (MRO), or by attempting to combine multiple builtin classes in a class's MRO.</p> <p>Why is this bad?</p> <p>Inheriting from bases with conflicting instance memory layouts will lead to a <code>TypeError</code> at runtime.</p> <p>An instance memory layout conflict occurs when CPython cannot determine the memory layout instances of a class should have, because the instance memory layout of one of its bases conflicts with the instance memory layout of one or more of its other bases.</p> <p>For example, if a Python class defines non-empty <code>__slots__</code>, this will impact the memory layout of instances of that class. Multiple inheritance from more than one different class defining non-empty <code>__slots__</code> is not allowed:</p> <pre><code>class A:\n    __slots__ = (\"a\", \"b\")\n\nclass B:\n    __slots__ = (\"a\", \"b\")  # Even if the values are the same\n\n# TypeError: multiple bases have instance lay-out conflict\nclass C(A, B): ...\n</code></pre> <p>An instance layout conflict can also be caused by attempting to use multiple inheritance with two builtin classes, due to the way that these classes are implemented in a CPython C extension:</p> <pre><code>class A(int, float): ...  # TypeError: multiple bases have instance lay-out conflict\n</code></pre> <p>Note that pure-Python classes with no <code>__slots__</code>, or pure-Python classes with empty <code>__slots__</code>, are always compatible:</p> <pre><code>class A: ...\nclass B:\n    __slots__ = ()\nclass C:\n    __slots__ = (\"a\", \"b\")\n\n# fine\nclass D(A, B, C): ...\n</code></pre> <p>Known problems</p> <p>Classes that have \"dynamic\" definitions of <code>__slots__</code> (definitions do not consist of string literals, or tuples of string literals) are not currently considered disjoint bases by ty.</p> <p>Additionally, this check is not exhaustive: many C extensions (including several in the standard library) define classes that use extended memory layouts and thus cannot coexist in a single MRO. Since it is currently not possible to represent this fact in stub files, having a full knowledge of these classes is also impossible. When it comes to classes that do not define <code>__slots__</code> at the Python level, therefore, ty, currently only hard-codes a number of cases where it knows that a class will produce instances with an atypical memory layout.</p> <p>Further reading</p> <ul> <li>CPython documentation: <code>__slots__</code></li> <li>CPython documentation: Method Resolution Order</li> </ul>"},{"location":"reference/rules/#invalid-argument-type","title":"<code>invalid-argument-type</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects call arguments whose type is not assignable to the corresponding typed parameter.</p> <p>Why is this bad?</p> <p>Passing an argument of a type the function (or callable object) does not accept violates the expectations of the function author and may cause unexpected runtime errors within the body of the function.</p> <p>Examples</p> <pre><code>def func(x: int): ...\nfunc(\"foo\")  # error: [invalid-argument-type]\n</code></pre>"},{"location":"reference/rules/#invalid-assignment","title":"<code>invalid-assignment</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for assignments where the type of the value is not assignable to the type of the assignee.</p> <p>Why is this bad?</p> <p>Such assignments break the rules of the type system and weaken a type checker's ability to accurately reason about your code.</p> <p>Examples</p> <pre><code>a: int = ''\n</code></pre>"},{"location":"reference/rules/#invalid-attribute-access","title":"<code>invalid-attribute-access</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for assignments to class variables from instances and assignments to instance variables from its class.</p> <p>Why is this bad?</p> <p>Incorrect assignments break the rules of the type system and weaken a type checker's ability to accurately reason about your code.</p> <p>Examples</p> <pre><code>class C:\n    class_var: ClassVar[int] = 1\n    instance_var: int\n\nC.class_var = 3  # okay\nC().class_var = 3  # error: Cannot assign to class variable\n\nC().instance_var = 3  # okay\nC.instance_var = 3  # error: Cannot assign to instance variable\n</code></pre>"},{"location":"reference/rules/#invalid-await","title":"<code>invalid-await</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.19 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for <code>await</code> being used with types that are not Awaitable.</p> <p>Why is this bad?</p> <p>Such expressions will lead to <code>TypeError</code> being raised at runtime.</p> <p>Examples</p> <pre><code>import asyncio\n\nclass InvalidAwait:\n    def __await__(self) -&gt; int:\n        return 5\n\nasync def main() -&gt; None:\n    await InvalidAwait()  # error: [invalid-await]\n    await 42  # error: [invalid-await]\n\nasyncio.run(main())\n</code></pre>"},{"location":"reference/rules/#invalid-base","title":"<code>invalid-base</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions that have bases which are not instances of <code>type</code>.</p> <p>Why is this bad?</p> <p>Class definitions with bases like this will lead to <code>TypeError</code> being raised at runtime.</p> <p>Examples</p> <pre><code>class A(42): ...  # error: [invalid-base]\n</code></pre>"},{"location":"reference/rules/#invalid-context-manager","title":"<code>invalid-context-manager</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for expressions used in <code>with</code> statements that do not implement the context manager protocol.</p> <p>Why is this bad?</p> <p>Such a statement will raise <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code># TypeError: 'int' object does not support the context manager protocol\nwith 1:\n    print(2)\n</code></pre>"},{"location":"reference/rules/#invalid-declaration","title":"<code>invalid-declaration</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for declarations where the inferred type of an existing symbol is not assignable to its post-hoc declared type.</p> <p>Why is this bad?</p> <p>Such declarations break the rules of the type system and weaken a type checker's ability to accurately reason about your code.</p> <p>Examples</p> <pre><code>a = 1\na: str\n</code></pre>"},{"location":"reference/rules/#invalid-exception-caught","title":"<code>invalid-exception-caught</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for exception handlers that catch non-exception classes.</p> <p>Why is this bad?</p> <p>Catching classes that do not inherit from <code>BaseException</code> will raise a <code>TypeError</code> at runtime.</p> <p>Example</p> <pre><code>try:\n    1 / 0\nexcept 1:\n    ...\n</code></pre> <p>Use instead: <pre><code>try:\n    1 / 0\nexcept ZeroDivisionError:\n    ...\n</code></pre></p> <p>References</p> <ul> <li>Python documentation: except clause</li> <li>Python documentation: Built-in Exceptions</li> </ul> <p>Ruff rule</p> <p>This rule corresponds to Ruff's <code>except-with-non-exception-classes</code> (<code>B030</code>)</p>"},{"location":"reference/rules/#invalid-explicit-override","title":"<code>invalid-explicit-override</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.28 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for methods that are decorated with <code>@override</code> but do not override any method in a superclass.</p> <p>Why is this bad?</p> <p>Decorating a method with <code>@override</code> declares to the type checker that the intention is that it should override a method from a superclass.</p> <p>Example</p> <pre><code>from typing import override\n\nclass A:\n    @override\n    def foo(self): ...  # Error raised here\n\nclass B(A):\n    @override\n    def ffooo(self): ...  # Error raised here\n\nclass C:\n    @override\n    def __repr__(self): ...  # fine: overrides `object.__repr__`\n\nclass D(A):\n    @override\n    def foo(self): ...  # fine: overrides `A.foo`\n</code></pre>"},{"location":"reference/rules/#invalid-frozen-dataclass-subclass","title":"<code>invalid-frozen-dataclass-subclass</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.35 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for dataclasses with invalid frozen inheritance: - A frozen dataclass cannot inherit from a non-frozen dataclass. - A non-frozen dataclass cannot inherit from a frozen dataclass.</p> <p>Why is this bad?</p> <p>Python raises a <code>TypeError</code> at runtime when either of these inheritance patterns occurs.</p> <p>Example</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Base:\n    x: int\n\n@dataclass(frozen=True)\nclass Child(Base):  # Error raised here\n    y: int\n\n@dataclass(frozen=True)\nclass FrozenBase:\n    x: int\n\n@dataclass\nclass NonFrozenChild(FrozenBase):  # Error raised here\n    y: int\n</code></pre>"},{"location":"reference/rules/#invalid-generic-class","title":"<code>invalid-generic-class</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for the creation of invalid generic classes</p> <p>Why is this bad?</p> <p>There are several requirements that you must follow when defining a generic class. Many of these result in <code>TypeError</code> being raised at runtime if they are violated.</p> <p>Examples</p> <pre><code>from typing_extensions import Generic, TypeVar\n\nT = TypeVar(\"T\")\nU = TypeVar(\"U\", default=int)\n\n# error: class uses both PEP-695 syntax and legacy syntax\nclass C[U](Generic[T]): ...\n\n# error: type parameter with default comes before type parameter without default\nclass D(Generic[U, T]): ...\n</code></pre> <p>References</p> <ul> <li>Typing spec: Generics</li> </ul>"},{"location":"reference/rules/#invalid-key","title":"<code>invalid-key</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.17 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for subscript accesses with invalid keys and <code>TypedDict</code> construction with an unknown key.</p> <p>Why is this bad?</p> <p>Subscripting with an invalid key will raise a <code>KeyError</code> at runtime.</p> <p>Creating a <code>TypedDict</code> with an unknown key is likely a mistake; if the <code>TypedDict</code> is <code>closed=true</code> it also violates the expectations of the type.</p> <p>Examples</p> <pre><code>from typing import TypedDict\n\nclass Person(TypedDict):\n    name: str\n    age: int\n\nalice = Person(name=\"Alice\", age=30)\nalice[\"height\"]  # KeyError: 'height'\n\nbob: Person = { \"name\": \"Bob\", \"age\": 30 }  # typo!\n\ncarol = Person(name=\"Carol\", age=25)  # typo!\n</code></pre>"},{"location":"reference/rules/#invalid-legacy-type-variable","title":"<code>invalid-legacy-type-variable</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for the creation of invalid legacy <code>TypeVar</code>s</p> <p>Why is this bad?</p> <p>There are several requirements that you must follow when creating a legacy <code>TypeVar</code>.</p> <p>Examples</p> <pre><code>from typing import TypeVar\n\nT = TypeVar(\"T\")  # okay\nQ = TypeVar(\"S\")  # error: TypeVar name must match the variable it's assigned to\nT = TypeVar(\"T\")  # error: TypeVars should not be redefined\n\n# error: TypeVar must be immediately assigned to a variable\ndef f(t: TypeVar(\"U\")): ...\n</code></pre> <p>References</p> <ul> <li>Typing spec: Generics</li> </ul>"},{"location":"reference/rules/#invalid-metaclass","title":"<code>invalid-metaclass</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for arguments to <code>metaclass=</code> that are invalid.</p> <p>Why is this bad?</p> <p>Python allows arbitrary expressions to be used as the argument to <code>metaclass=</code>. These expressions, however, need to be callable and accept the same arguments as <code>type.__new__</code>.</p> <p>Example</p> <pre><code>def f(): ...\n\n# TypeError: f() takes 0 positional arguments but 3 were given\nclass B(metaclass=f): ...\n</code></pre> <p>References</p> <ul> <li>Python documentation: Metaclasses</li> </ul>"},{"location":"reference/rules/#invalid-method-override","title":"<code>invalid-method-override</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.20 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects method overrides that violate the Liskov Substitution Principle (\"LSP\").</p> <p>The LSP states that an instance of a subtype should be substitutable for an instance of its supertype. Applied to Python, this means: 1. All argument combinations a superclass method accepts    must also be accepted by an overriding subclass method. 2. The return type of an overriding subclass method must be a subtype    of the return type of the superclass method.</p> <p>Why is this bad?</p> <p>Violating the Liskov Substitution Principle will lead to many of ty's assumptions and inferences being incorrect, which will mean that it will fail to catch many possible type errors in your code.</p> <p>Example</p> <pre><code>class Super:\n    def method(self, x) -&gt; int:\n        return 42\n\nclass Sub(Super):\n    # Liskov violation: `str` is not a subtype of `int`,\n    # but the supertype method promises to return an `int`.\n    def method(self, x) -&gt; str:  # error: [invalid-override]\n        return \"foo\"\n\ndef accepts_super(s: Super) -&gt; int:\n    return s.method(x=42)\n\naccepts_super(Sub())  # The result of this call is a string, but ty will infer\n                      # it to be an `int` due to the violation of the Liskov Substitution Principle.\n\nclass Sub2(Super):\n    # Liskov violation: the superclass method can be called with a `x=`\n    # keyword argument, but the subclass method does not accept it.\n    def method(self, y) -&gt; int:  # error: [invalid-override]\n       return 42\n\naccepts_super(Sub2())  # TypeError at runtime: method() got an unexpected keyword argument 'x'\n                       # ty cannot catch this error due to the violation of the Liskov Substitution Principle.\n</code></pre> <p>Common issues</p> <p>Why does ty complain about my <code>__eq__</code> method?</p> <p><code>__eq__</code> and <code>__ne__</code> methods in Python are generally expected to accept arbitrary objects as their second argument, for example:</p> <pre><code>class A:\n    x: int\n\n    def __eq__(self, other: object) -&gt; bool:\n        # gracefully handle an object of an unexpected type\n        # without raising an exception\n        if not isinstance(other, A):\n            return False\n        return self.x == other.x\n</code></pre> <p>If <code>A.__eq__</code> here were annotated as only accepting <code>A</code> instances for its second argument, it would imply that you wouldn't be able to use <code>==</code> between instances of <code>A</code> and instances of unrelated classes without an exception possibly being raised. While some classes in Python do indeed behave this way, the strongly held convention is that it should be avoided wherever possible. As part of this check, therefore, ty enforces that <code>__eq__</code> and <code>__ne__</code> methods accept <code>object</code> as their second argument.</p> <p>Why does ty disagree with Ruff about how to write my method?</p> <p>Ruff has several rules that will encourage you to rename a parameter, or change its type signature, if it thinks you're falling into a certain anti-pattern. For example, Ruff's ARG002 rule recommends that an unused parameter should either be removed or renamed to start with <code>_</code>. Applying either of these suggestions can cause ty to start reporting an <code>invalid-method-override</code> error if the function in question is a method on a subclass that overrides a method on a superclass, and the change would cause the subclass method to no longer accept all argument combinations that the superclass method accepts.</p> <p>This can usually be resolved by adding <code>@typing.override</code> to your method definition. Ruff knows that a method decorated with <code>@typing.override</code> is intended to override a method by the same name on a superclass, and avoids reporting rules like ARG002 for such methods; it knows that the changes recommended by ARG002 would violate the Liskov Substitution Principle.</p> <p>Correct use of <code>@override</code> is enforced by ty's <code>invalid-explicit-override</code> rule.</p>"},{"location":"reference/rules/#invalid-named-tuple","title":"<code>invalid-named-tuple</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.19 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for invalidly defined <code>NamedTuple</code> classes.</p> <p>Why is this bad?</p> <p>An invalidly defined <code>NamedTuple</code> class may lead to the type checker drawing incorrect conclusions. It may also lead to <code>TypeError</code>s or <code>AttributeError</code>s at runtime.</p> <p>Examples</p> <p>A class definition cannot combine <code>NamedTuple</code> with other base classes in multiple inheritance; doing so raises a <code>TypeError</code> at runtime. The sole exception to this rule is <code>Generic[]</code>, which can be used alongside <code>NamedTuple</code> in a class's bases list.</p> <pre><code>&gt;&gt;&gt; from typing import NamedTuple\n&gt;&gt;&gt; class Foo(NamedTuple, object): ...\nTypeError: can only inherit from a NamedTuple type and Generic\n</code></pre> <p>Further, <code>NamedTuple</code> field names cannot start with an underscore:</p> <pre><code>&gt;&gt;&gt; from typing import NamedTuple\n&gt;&gt;&gt; class Foo(NamedTuple):\n...     _bar: int\nValueError: Field names cannot start with an underscore: '_bar'\n</code></pre> <p><code>NamedTuple</code> classes also have certain synthesized attributes (like <code>_asdict</code>, <code>_make</code>, <code>_replace</code>, etc.) that cannot be overwritten. Attempting to assign to these attributes without a type annotation will raise an <code>AttributeError</code> at runtime.</p> <pre><code>&gt;&gt;&gt; from typing import NamedTuple\n&gt;&gt;&gt; class Foo(NamedTuple):\n...     x: int\n...     _asdict = 42\nAttributeError: Cannot overwrite NamedTuple attribute _asdict\n</code></pre>"},{"location":"reference/rules/#invalid-newtype","title":"<code>invalid-newtype</code>","text":"<p> Default level: <code>error</code> \u00b7 Preview (since 1.0.0) \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for the creation of invalid <code>NewType</code>s</p> <p>Why is this bad?</p> <p>There are several requirements that you must follow when creating a <code>NewType</code>.</p> <p>Examples</p> <pre><code>from typing import NewType\n\ndef get_name() -&gt; str: ...\n\nFoo = NewType(\"Foo\", int)        # okay\nBar = NewType(get_name(), int)   # error: The first argument to `NewType` must be a string literal\nBaz = NewType(\"Baz\", int | str)  # error: invalid base for `typing.NewType`\n</code></pre>"},{"location":"reference/rules/#invalid-overload","title":"<code>invalid-overload</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for various invalid <code>@overload</code> usages.</p> <p>Why is this bad?</p> <p>The <code>@overload</code> decorator is used to define functions and methods that accepts different combinations of arguments and return different types based on the arguments passed. This is mainly beneficial for type checkers. But, if the <code>@overload</code> usage is invalid, the type checker may not be able to provide correct type information.</p> <p>Example</p> <p>Defining only one overload:</p> <pre><code>from typing import overload\n\n@overload\ndef foo(x: int) -&gt; int: ...\ndef foo(x: int | None) -&gt; int | None:\n    return x\n</code></pre> <p>Or, not providing an implementation for the overloaded definition:</p> <pre><code>from typing import overload\n\n@overload\ndef foo() -&gt; None: ...\n@overload\ndef foo(x: int) -&gt; int: ...\n</code></pre> <p>References</p> <ul> <li>Python documentation: <code>@overload</code></li> </ul>"},{"location":"reference/rules/#invalid-parameter-default","title":"<code>invalid-parameter-default</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for default values that can't be assigned to the parameter's annotated type.</p> <p>Why is this bad?</p> <p>This breaks the rules of the type system and weakens a type checker's ability to accurately reason about your code.</p> <p>Examples</p> <pre><code>def f(a: int = ''): ...\n</code></pre>"},{"location":"reference/rules/#invalid-paramspec","title":"<code>invalid-paramspec</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for the creation of invalid <code>ParamSpec</code>s</p> <p>Why is this bad?</p> <p>There are several requirements that you must follow when creating a <code>ParamSpec</code>.</p> <p>Examples</p> <pre><code>from typing import ParamSpec\n\nP1 = ParamSpec(\"P1\")  # okay\nP2 = ParamSpec(\"S2\")  # error: ParamSpec name must match the variable it's assigned to\n</code></pre> <p>References</p> <ul> <li>Typing spec: ParamSpec</li> </ul>"},{"location":"reference/rules/#invalid-protocol","title":"<code>invalid-protocol</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for protocol classes that will raise <code>TypeError</code> at runtime.</p> <p>Why is this bad?</p> <p>An invalidly defined protocol class may lead to the type checker inferring unexpected things. It may also lead to <code>TypeError</code>s at runtime.</p> <p>Examples</p> <p>A <code>Protocol</code> class cannot inherit from a non-<code>Protocol</code> class; this raises a <code>TypeError</code> at runtime:</p> <pre><code>&gt;&gt;&gt; from typing import Protocol\n&gt;&gt;&gt; class Foo(int, Protocol): ...\n...\nTraceback (most recent call last):\n  File \"&lt;python-input-1&gt;\", line 1, in &lt;module&gt;\n    class Foo(int, Protocol): ...\nTypeError: Protocols can only inherit from other protocols, got &lt;class 'int'&gt;\n</code></pre>"},{"location":"reference/rules/#invalid-raise","title":"<code>invalid-raise</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>Checks for <code>raise</code> statements that raise non-exceptions or use invalid causes for their raised exceptions.</p> <p>Why is this bad?</p> <p>Only subclasses or instances of <code>BaseException</code> can be raised. For an exception's cause, the same rules apply, except that <code>None</code> is also permitted. Violating these rules results in a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>def f():\n    try:\n        something()\n    except NameError:\n        raise \"oops!\" from f\n\ndef g():\n    raise NotImplemented from 42\n</code></pre> <p>Use instead: <pre><code>def f():\n    try:\n        something()\n    except NameError as e:\n        raise RuntimeError(\"oops!\") from e\n\ndef g():\n    raise NotImplementedError from None\n</code></pre></p> <p>References</p> <ul> <li>Python documentation: The <code>raise</code> statement</li> <li>Python documentation: Built-in Exceptions</li> </ul>"},{"location":"reference/rules/#invalid-return-type","title":"<code>invalid-return-type</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects returned values that can't be assigned to the function's annotated return type.</p> <p>Why is this bad?</p> <p>Returning an object of a type incompatible with the annotated return type may cause confusion to the user calling the function.</p> <p>Examples</p> <pre><code>def func() -&gt; int:\n    return \"a\"  # error: [invalid-return-type]\n</code></pre>"},{"location":"reference/rules/#invalid-super-argument","title":"<code>invalid-super-argument</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects <code>super()</code> calls where: - the first argument is not a valid class literal, or - the second argument is not an instance or subclass of the first argument.</p> <p>Why is this bad?</p> <p><code>super(type, obj)</code> expects: - the first argument to be a class, - and the second argument to satisfy one of the following:   - <code>isinstance(obj, type)</code> is <code>True</code>   - <code>issubclass(obj, type)</code> is <code>True</code></p> <p>Violating this relationship will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A:\n    ...\nclass B(A):\n    ...\n\nsuper(A, B())  # it's okay! `A` satisfies `isinstance(B(), A)`\n\nsuper(A(), B()) # error: `A()` is not a class\n\nsuper(B, A())  # error: `A()` does not satisfy `isinstance(A(), B)`\nsuper(B, A)  # error: `A` does not satisfy `issubclass(A, B)`\n</code></pre> <p>References</p> <ul> <li>Python documentation: super()</li> </ul>"},{"location":"reference/rules/#invalid-syntax-in-forward-annotation","title":"<code>invalid-syntax-in-forward-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>TODO #14889</p>"},{"location":"reference/rules/#invalid-type-alias-type","title":"<code>invalid-type-alias-type</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.6 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for the creation of invalid <code>TypeAliasType</code>s</p> <p>Why is this bad?</p> <p>There are several requirements that you must follow when creating a <code>TypeAliasType</code>.</p> <p>Examples</p> <pre><code>from typing import TypeAliasType\n\nIntOrStr = TypeAliasType(\"IntOrStr\", int | str)  # okay\nNewAlias = TypeAliasType(get_name(), int)        # error: TypeAliasType name must be a string literal\n</code></pre>"},{"location":"reference/rules/#invalid-type-arguments","title":"<code>invalid-type-arguments</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.29 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for invalid type arguments in explicit type specialization.</p> <p>Why is this bad?</p> <p>Providing the wrong number of type arguments or type arguments that don't satisfy the type variable's bounds or constraints will lead to incorrect type inference and may indicate a misunderstanding of the generic type's interface.</p> <p>Examples</p> <p>Using legacy type variables: <pre><code>from typing import Generic, TypeVar\n\nT1 = TypeVar('T1', int, str)\nT2 = TypeVar('T2', bound=int)\n\nclass Foo1(Generic[T1]): ...\nclass Foo2(Generic[T2]): ...\n\nFoo1[bytes]  # error: bytes does not satisfy T1's constraints\nFoo2[str]  # error: str does not satisfy T2's bound\n</code></pre></p> <p>Using PEP 695 type variables: <pre><code>class Foo[T]: ...\nclass Bar[T, U]: ...\n\nFoo[int, str]  # error: too many arguments\nBar[int]  # error: too few arguments\n</code></pre></p>"},{"location":"reference/rules/#invalid-type-checking-constant","title":"<code>invalid-type-checking-constant</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for a value other than <code>False</code> assigned to the <code>TYPE_CHECKING</code> variable, or an annotation not assignable from <code>bool</code>.</p> <p>Why is this bad?</p> <p>The name <code>TYPE_CHECKING</code> is reserved for a flag that can be used to provide conditional code seen only by the type checker, and not at runtime. Normally this flag is imported from <code>typing</code> or <code>typing_extensions</code>, but it can also be defined locally. If defined locally, it must be assigned the value <code>False</code> at runtime; the type checker will consider its value to be <code>True</code>. If annotated, it must be annotated as a type that can accept <code>bool</code> values.</p> <p>Examples</p> <pre><code>TYPE_CHECKING: str\nTYPE_CHECKING = ''\n</code></pre>"},{"location":"reference/rules/#invalid-type-form","title":"<code>invalid-type-form</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for expressions that are used as type expressions but cannot validly be interpreted as such.</p> <p>Why is this bad?</p> <p>Such expressions cannot be understood by ty. In some cases, they might raise errors at runtime.</p> <p>Examples</p> <pre><code>from typing import Annotated\n\na: type[1]  # `1` is not a type\nb: Annotated[int]  # `Annotated` expects at least two arguments\n</code></pre>"},{"location":"reference/rules/#invalid-type-guard-call","title":"<code>invalid-type-guard-call</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.11 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for type guard function calls without a valid target.</p> <p>Why is this bad?</p> <p>The first non-keyword non-variadic argument to a type guard function is its target and must map to a symbol.</p> <p>Starred (<code>is_str(*a)</code>), literal (<code>is_str(42)</code>) and other non-symbol-like expressions are invalid as narrowing targets.</p> <p>Examples</p> <pre><code>from typing import TypeIs\n\ndef f(v: object) -&gt; TypeIs[int]: ...\n\nf()  # Error\nf(*a)  # Error\nf(10)  # Error\n</code></pre>"},{"location":"reference/rules/#invalid-type-guard-definition","title":"<code>invalid-type-guard-definition</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.11 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for type guard functions without a first non-self-like non-keyword-only non-variadic parameter.</p> <p>Why is this bad?</p> <p>Type narrowing functions must accept at least one positional argument (non-static methods must accept another in addition to <code>self</code>/<code>cls</code>).</p> <p>Extra parameters/arguments are allowed but do not affect narrowing.</p> <p>Examples</p> <pre><code>from typing import TypeIs\n\ndef f() -&gt; TypeIs[int]: ...  # Error, no parameter\ndef f(*, v: object) -&gt; TypeIs[int]: ...  # Error, no positional arguments allowed\ndef f(*args: object) -&gt; TypeIs[int]: ... # Error, expect variadic arguments\nclass C:\n    def f(self) -&gt; TypeIs[int]: ...  # Error, only positional argument expected is `self`\n</code></pre>"},{"location":"reference/rules/#invalid-type-variable-constraints","title":"<code>invalid-type-variable-constraints</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for constrained type variables with only one constraint.</p> <p>Why is this bad?</p> <p>A constrained type variable must have at least two constraints.</p> <p>Examples</p> <pre><code>from typing import TypeVar\n\nT = TypeVar('T', str)  # invalid constrained TypeVar\n</code></pre> <p>Use instead: <pre><code>T = TypeVar('T', str, int)  # valid constrained TypeVar\n# or\nT = TypeVar('T', bound=str)  # valid bound TypeVar\n</code></pre></p>"},{"location":"reference/rules/#missing-argument","title":"<code>missing-argument</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for missing required arguments in a call.</p> <p>Why is this bad?</p> <p>Failing to provide a required argument will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>def func(x: int): ...\nfunc()  # TypeError: func() missing 1 required positional argument: 'x'\n</code></pre>"},{"location":"reference/rules/#missing-typed-dict-key","title":"<code>missing-typed-dict-key</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.20 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects missing required keys in <code>TypedDict</code> constructor calls.</p> <p>Why is this bad?</p> <p><code>TypedDict</code> requires all non-optional keys to be provided during construction. Missing items can lead to a <code>KeyError</code> at runtime.</p> <p>Example</p> <pre><code>from typing import TypedDict\n\nclass Person(TypedDict):\n    name: str\n    age: int\n\nalice: Person = {\"name\": \"Alice\"}  # missing required key 'age'\n\nalice[\"age\"]  # KeyError\n</code></pre>"},{"location":"reference/rules/#no-matching-overload","title":"<code>no-matching-overload</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls to an overloaded function that do not match any of the overloads.</p> <p>Why is this bad?</p> <p>Failing to provide the correct arguments to one of the overloads will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>@overload\ndef func(x: int): ...\n@overload\ndef func(x: bool): ...\nfunc(\"string\")  # error: [no-matching-overload]\n</code></pre>"},{"location":"reference/rules/#non-subscriptable","title":"<code>non-subscriptable</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for subscripting objects that do not support subscripting.</p> <p>Why is this bad?</p> <p>Subscripting an object that does not support it will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>4[1]  # TypeError: 'int' object is not subscriptable\n</code></pre>"},{"location":"reference/rules/#not-iterable","title":"<code>not-iterable</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for objects that are not iterable but are used in a context that requires them to be.</p> <p>Why is this bad?</p> <p>Iterating over an object that is not iterable will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>for i in 34:  # TypeError: 'int' object is not iterable\n    pass\n</code></pre>"},{"location":"reference/rules/#override-of-final-method","title":"<code>override-of-final-method</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.29 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for methods on subclasses that override superclass methods decorated with <code>@final</code>.</p> <p>Why is this bad?</p> <p>Decorating a method with <code>@final</code> declares to the type checker that it should not be overridden on any subclass.</p> <p>Example</p> <pre><code>from typing import final\n\nclass A:\n    @final\n    def foo(self): ...\n\nclass B(A):\n    def foo(self): ...  # Error raised here\n</code></pre>"},{"location":"reference/rules/#parameter-already-assigned","title":"<code>parameter-already-assigned</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls which provide more than one argument for a single parameter.</p> <p>Why is this bad?</p> <p>Providing multiple values for a single parameter will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>def f(x: int) -&gt; int: ...\n\nf(1, x=2)  # Error raised here\n</code></pre>"},{"location":"reference/rules/#positional-only-parameter-as-kwarg","title":"<code>positional-only-parameter-as-kwarg</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.22 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for keyword arguments in calls that match positional-only parameters of the callable.</p> <p>Why is this bad?</p> <p>Providing a positional-only parameter as a keyword argument will raise <code>TypeError</code> at runtime.</p> <p>Example</p> <pre><code>def f(x: int, /) -&gt; int: ...\n\nf(x=1)  # Error raised here\n</code></pre>"},{"location":"reference/rules/#raw-string-type-annotation","title":"<code>raw-string-type-annotation</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for raw-strings in type annotation positions.</p> <p>Why is this bad?</p> <p>Static analysis tools like ty can't analyze type annotations that use raw-string notation.</p> <p>Examples</p> <pre><code>def test(): -&gt; r\"int\":\n    ...\n</code></pre> <p>Use instead: <pre><code>def test(): -&gt; \"int\":\n    ...\n</code></pre></p>"},{"location":"reference/rules/#static-assert-error","title":"<code>static-assert-error</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Makes sure that the argument of <code>static_assert</code> is statically known to be true.</p> <p>Why is this bad?</p> <p>A <code>static_assert</code> call represents an explicit request from the user for the type checker to emit an error if the argument cannot be verified to evaluate to <code>True</code> in a boolean context.</p> <p>Examples</p> <pre><code>from ty_extensions import static_assert\n\nstatic_assert(1 + 1 == 3)  # error: evaluates to `False`\n\nstatic_assert(int(2.0 * 3.0) == 6)  # error: does not have a statically known truthiness\n</code></pre>"},{"location":"reference/rules/#subclass-of-final-class","title":"<code>subclass-of-final-class</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for classes that subclass final classes.</p> <p>Why is this bad?</p> <p>Decorating a class with <code>@final</code> declares to the type checker that it should not be subclassed.</p> <p>Example</p> <pre><code>from typing import final\n\n@final\nclass A: ...\nclass B(A): ...  # Error raised here\n</code></pre>"},{"location":"reference/rules/#super-call-in-named-tuple-method","title":"<code>super-call-in-named-tuple-method</code>","text":"<p> Default level: <code>error</code> \u00b7 Preview (since 0.0.1-alpha.30) \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls to <code>super()</code> inside methods of <code>NamedTuple</code> classes.</p> <p>Why is this bad?</p> <p>Using <code>super()</code> in a method of a <code>NamedTuple</code> class will raise an exception at runtime.</p> <p>Examples</p> <pre><code>from typing import NamedTuple\n\nclass F(NamedTuple):\n    x: int\n\n    def method(self):\n        super()  # error: super() is not supported in methods of NamedTuple classes\n</code></pre> <p>References</p> <ul> <li>Python documentation: super()</li> </ul>"},{"location":"reference/rules/#too-many-positional-arguments","title":"<code>too-many-positional-arguments</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls that pass more positional arguments than the callable can accept.</p> <p>Why is this bad?</p> <p>Passing too many positional arguments will raise <code>TypeError</code> at runtime.</p> <p>Example</p> <pre><code>def f(): ...\n\nf(\"foo\")  # Error raised here\n</code></pre>"},{"location":"reference/rules/#type-assertion-failure","title":"<code>type-assertion-failure</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for <code>assert_type()</code> and <code>assert_never()</code> calls where the actual type is not the same as the asserted type.</p> <p>Why is this bad?</p> <p><code>assert_type()</code> allows confirming the inferred type of a certain value.</p> <p>Example</p> <pre><code>def _(x: int):\n    assert_type(x, int)  # fine\n    assert_type(x, str)  # error: Actual type does not match asserted type\n</code></pre>"},{"location":"reference/rules/#unavailable-implicit-super-arguments","title":"<code>unavailable-implicit-super-arguments</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects invalid <code>super()</code> calls where implicit arguments like the enclosing class or first method argument are unavailable.</p> <p>Why is this bad?</p> <p>When <code>super()</code> is used without arguments, Python tries to find two things: the nearest enclosing class and the first argument of the immediately enclosing function (typically self or cls). If either of these is missing, the call will fail at runtime with a <code>RuntimeError</code>.</p> <p>Examples</p> <pre><code>super()  # error: no enclosing class or function found\n\ndef func():\n    super()  # error: no enclosing class or first argument exists\n\nclass A:\n    f = super()  # error: no enclosing function to provide the first argument\n\n    def method(self):\n        def nested():\n            super()  # error: first argument does not exist in this nested function\n\n        lambda: super()  # error: first argument does not exist in this lambda\n\n        (super() for _ in range(10))  # error: argument is not available in generator expression\n\n        super()  # okay! both enclosing class and first argument are available\n</code></pre> <p>References</p> <ul> <li>Python documentation: super()</li> </ul>"},{"location":"reference/rules/#unknown-argument","title":"<code>unknown-argument</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for keyword arguments in calls that don't match any parameter of the callable.</p> <p>Why is this bad?</p> <p>Providing an unknown keyword argument will raise <code>TypeError</code> at runtime.</p> <p>Example</p> <pre><code>def f(x: int) -&gt; int: ...\n\nf(x=1, y=2)  # Error raised here\n</code></pre>"},{"location":"reference/rules/#unresolved-attribute","title":"<code>unresolved-attribute</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for unresolved attributes.</p> <p>Why is this bad?</p> <p>Accessing an unbound attribute will raise an <code>AttributeError</code> at runtime. An unresolved attribute is not guaranteed to exist from the type alone, so this could also indicate that the object is not of the type that the user expects.</p> <p>Examples</p> <pre><code>class A: ...\n\nA().foo  # AttributeError: 'A' object has no attribute 'foo'\n</code></pre>"},{"location":"reference/rules/#unresolved-import","title":"<code>unresolved-import</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for import statements for which the module cannot be resolved.</p> <p>Why is this bad?</p> <p>Importing a module that cannot be resolved will raise a <code>ModuleNotFoundError</code> at runtime.</p> <p>Examples</p> <pre><code>import foo  # ModuleNotFoundError: No module named 'foo'\n</code></pre>"},{"location":"reference/rules/#unresolved-reference","title":"<code>unresolved-reference</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for references to names that are not defined.</p> <p>Why is this bad?</p> <p>Using an undefined variable will raise a <code>NameError</code> at runtime.</p> <p>Example</p> <pre><code>print(x)  # NameError: name 'x' is not defined\n</code></pre>"},{"location":"reference/rules/#unsupported-bool-conversion","title":"<code>unsupported-bool-conversion</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for bool conversions where the object doesn't correctly implement <code>__bool__</code>.</p> <p>Why is this bad?</p> <p>If an exception is raised when you attempt to evaluate the truthiness of an object, using the object in a boolean context will fail at runtime.</p> <p>Examples</p> <pre><code>class NotBoolable:\n    __bool__ = None\n\nb1 = NotBoolable()\nb2 = NotBoolable()\n\nif b1:  # exception raised here\n    pass\n\nb1 and b2  # exception raised here\nnot b1  # exception raised here\nb1 &lt; b2 &lt; b1  # exception raised here\n</code></pre>"},{"location":"reference/rules/#unsupported-operator","title":"<code>unsupported-operator</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for binary expressions, comparisons, and unary expressions where the operands don't support the operator.</p> <p>Why is this bad?</p> <p>Attempting to use an unsupported operator will raise a <code>TypeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A: ...\n\nA() + A()  # TypeError: unsupported operand type(s) for +: 'A' and 'A'\n</code></pre>"},{"location":"reference/rules/#zero-stepsize-in-slice","title":"<code>zero-stepsize-in-slice</code>","text":"<p> Default level: <code>error</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for step size 0 in slices.</p> <p>Why is this bad?</p> <p>A slice with a step size of zero will raise a <code>ValueError</code> at runtime.</p> <p>Examples</p> <pre><code>l = list(range(10))\nl[1:10:0]  # ValueError: slice step cannot be zero\n</code></pre>"},{"location":"reference/rules/#ambiguous-protocol-member","title":"<code>ambiguous-protocol-member</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.20 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for protocol classes with members that will lead to ambiguous interfaces.</p> <p>Why is this bad?</p> <p>Assigning to an undeclared variable in a protocol class leads to an ambiguous interface which may lead to the type checker inferring unexpected things. It's recommended to ensure that all members of a protocol class are explicitly declared.</p> <p>Examples</p> <pre><code>from typing import Protocol\n\nclass BaseProto(Protocol):\n    a: int                               # fine (explicitly declared as `int`)\n    def method_member(self) -&gt; int: ...  # fine: a method definition using `def` is considered a declaration\n    c = \"some variable\"                  # error: no explicit declaration, leading to ambiguity\n    b = method_member                    # error: no explicit declaration, leading to ambiguity\n\n    # error: this creates implicit assignments of `d` and `e` in the protocol class body.\n    # Were they really meant to be considered protocol members?\n    for d, e in enumerate(range(42)):\n        pass\n\nclass SubProto(BaseProto, Protocol):\n    a = 42  # fine (declared in superclass)\n</code></pre>"},{"location":"reference/rules/#deprecated","title":"<code>deprecated</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.16 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for uses of deprecated items</p> <p>Why is this bad?</p> <p>Deprecated items should no longer be used.</p> <p>Examples</p> <pre><code>@warnings.deprecated(\"use new_func instead\")\ndef old_func(): ...\n\nold_func()  # emits [deprecated] diagnostic\n</code></pre>"},{"location":"reference/rules/#ignore-comment-unknown-rule","title":"<code>ignore-comment-unknown-rule</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for <code>ty: ignore[code]</code> where <code>code</code> isn't a known lint rule.</p> <p>Why is this bad?</p> <p>A <code>ty: ignore[code]</code> directive with a <code>code</code> that doesn't match any known rule will not suppress any type errors, and is probably a mistake.</p> <p>Examples</p> <pre><code>a = 20 / 0  # ty: ignore[division-by-zer]\n</code></pre> <p>Use instead:</p> <pre><code>a = 20 / 0  # ty: ignore[division-by-zero]\n</code></pre>"},{"location":"reference/rules/#invalid-ignore-comment","title":"<code>invalid-ignore-comment</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for <code>type: ignore</code> and <code>ty: ignore</code> comments that are syntactically incorrect.</p> <p>Why is this bad?</p> <p>A syntactically incorrect ignore comment is probably a mistake and is useless.</p> <p>Examples</p> <pre><code>a = 20 / 0  # type: ignoree\n</code></pre> <p>Use instead:</p> <pre><code>a = 20 / 0  # type: ignore\n</code></pre>"},{"location":"reference/rules/#possibly-missing-attribute","title":"<code>possibly-missing-attribute</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.22 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for possibly missing attributes.</p> <p>Why is this bad?</p> <p>Attempting to access a missing attribute will raise an <code>AttributeError</code> at runtime.</p> <p>Examples</p> <pre><code>class A:\n    if b:\n        c = 0\n\nA.c  # AttributeError: type object 'A' has no attribute 'c'\n</code></pre>"},{"location":"reference/rules/#possibly-missing-implicit-call","title":"<code>possibly-missing-implicit-call</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.22 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for implicit calls to possibly missing methods.</p> <p>Why is this bad?</p> <p>Expressions such as <code>x[y]</code> and <code>x * y</code> call methods under the hood (<code>__getitem__</code> and <code>__mul__</code> respectively). Calling a missing method will raise an <code>AttributeError</code> at runtime.</p> <p>Examples</p> <pre><code>import datetime\n\nclass A:\n    if datetime.date.today().weekday() != 6:\n        def __getitem__(self, v): ...\n\nA()[0]  # TypeError: 'A' object is not subscriptable\n</code></pre>"},{"location":"reference/rules/#possibly-missing-import","title":"<code>possibly-missing-import</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.22 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for imports of symbols that may be missing.</p> <p>Why is this bad?</p> <p>Importing a missing module or name will raise a <code>ModuleNotFoundError</code> or <code>ImportError</code> at runtime.</p> <p>Examples</p> <pre><code># module.py\nimport datetime\n\nif datetime.date.today().weekday() != 6:\n    a = 1\n\n# main.py\nfrom module import a  # ImportError: cannot import name 'a' from 'module'\n</code></pre>"},{"location":"reference/rules/#redundant-cast","title":"<code>redundant-cast</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects redundant <code>cast</code> calls where the value already has the target type.</p> <p>Why is this bad?</p> <p>These casts have no effect and can be removed.</p> <p>Example</p> <pre><code>def f() -&gt; int:\n    return 10\n\ncast(int, f())  # Redundant\n</code></pre>"},{"location":"reference/rules/#undefined-reveal","title":"<code>undefined-reveal</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for calls to <code>reveal_type</code> without importing it.</p> <p>Why is this bad?</p> <p>Using <code>reveal_type</code> without importing it will raise a <code>NameError</code> at runtime.</p> <p>Examples</p> <pre><code>reveal_type(1)  # NameError: name 'reveal_type' is not defined\n</code></pre>"},{"location":"reference/rules/#unresolved-global","title":"<code>unresolved-global</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.15 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Detects variables declared as <code>global</code> in an inner scope that have no explicit bindings or declarations in the global scope.</p> <p>Why is this bad?</p> <p>Function bodies with <code>global</code> statements can run in any order (or not at all), which makes it hard for static analysis tools to infer the types of globals without explicit definitions or declarations.</p> <p>Example</p> <pre><code>def f():\n    global x  # unresolved global\n    x = 42\n\ndef g():\n    print(x)  # unresolved reference\n</code></pre> <p>Use instead:</p> <pre><code>x: int\n\ndef f():\n    global x\n    x = 42\n\ndef g():\n    print(x)\n</code></pre> <p>Or:</p> <pre><code>x: int | None = None\n\ndef f():\n    global x\n    x = 42\n\ndef g():\n    print(x)\n</code></pre>"},{"location":"reference/rules/#unsupported-base","title":"<code>unsupported-base</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.7 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for class definitions that have bases which are unsupported by ty.</p> <p>Why is this bad?</p> <p>If a class has a base that is an instance of a complex type such as a union type, ty will not be able to resolve the method resolution order (MRO) for the class. This will lead to an inferior understanding of your codebase and unpredictable type-checking behavior.</p> <p>Examples</p> <pre><code>import datetime\n\nclass A: ...\nclass B: ...\n\nif datetime.date.today().weekday() != 6:\n    C = A\nelse:\n    C = B\n\nclass D(C): ...  # error: [unsupported-base]\n</code></pre>"},{"location":"reference/rules/#useless-overload-body","title":"<code>useless-overload-body</code>","text":"<p> Default level: <code>warn</code> \u00b7 Added in 0.0.1-alpha.22 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for various <code>@overload</code>-decorated functions that have non-stub bodies.</p> <p>Why is this bad?</p> <p>Functions decorated with <code>@overload</code> are ignored at runtime; they are overridden by the implementation function that follows the series of overloads. While it is not illegal to provide a body for an <code>@overload</code>-decorated function, it may indicate a misunderstanding of how the <code>@overload</code> decorator works.</p> <p>Example</p> <pre><code>from typing import overload\n\n@overload\ndef foo(x: int) -&gt; int:\n    return x + 1  # will never be executed\n\n@overload\ndef foo(x: str) -&gt; str:\n    return \"Oh no, got a string\"  # will never be executed\n\ndef foo(x: int | str) -&gt; int | str:\n    raise Exception(\"unexpected type encountered\")\n</code></pre> <p>Use instead:</p> <pre><code>from typing import assert_never, overload\n\n@overload\ndef foo(x: int) -&gt; int: ...\n\n@overload\ndef foo(x: str) -&gt; str: ...\n\ndef foo(x: int | str) -&gt; int | str:\n    if isinstance(x, int):\n        return x + 1\n    elif isinstance(x, str):\n        return \"Oh no, got a string\"\n    else:\n        assert_never(x)\n</code></pre> <p>References</p> <ul> <li>Python documentation: <code>@overload</code></li> </ul>"},{"location":"reference/rules/#division-by-zero","title":"<code>division-by-zero</code>","text":"<p> Default level: <code>ignore</code> \u00b7 Preview (since 0.0.1-alpha.1) \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>It detects division by zero.</p> <p>Why is this bad?</p> <p>Dividing by zero raises a <code>ZeroDivisionError</code> at runtime.</p> <p>Examples</p> <pre><code>5 / 0\n</code></pre>"},{"location":"reference/rules/#possibly-unresolved-reference","title":"<code>possibly-unresolved-reference</code>","text":"<p> Default level: <code>ignore</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for references to names that are possibly not defined.</p> <p>Why is this bad?</p> <p>Using an undefined variable will raise a <code>NameError</code> at runtime.</p> <p>Example</p> <pre><code>for i in range(0):\n    x = i\n\nprint(x)  # NameError: name 'x' is not defined\n</code></pre>"},{"location":"reference/rules/#unused-ignore-comment","title":"<code>unused-ignore-comment</code>","text":"<p> Default level: <code>ignore</code> \u00b7 Added in 0.0.1-alpha.1 \u00b7 Related issues \u00b7 View source </p> <p>What it does</p> <p>Checks for <code>type: ignore</code> or <code>ty: ignore</code> directives that are no longer applicable.</p> <p>Why is this bad?</p> <p>A <code>type: ignore</code> directive that no longer matches any diagnostic violations is likely included by mistake, and should be removed to avoid confusion.</p> <p>Examples</p> <pre><code>a = 20 / 2  # ty: ignore[division-by-zero]\n</code></pre> <p>Use instead:</p> <pre><code>a = 20 / 2\n</code></pre>"},{"location":"reference/typing-faq/","title":"Typing FAQ","text":"<p>This page answers some commonly asked questions about ty and Python's type system.</p>"},{"location":"reference/typing-faq/#what-is-the-unknown-type-and-when-does-it-appear","title":"What is the <code>Unknown</code> type and when does it appear?","text":"<p><code>Unknown</code> is ty's way of representing a type that could not be fully inferred. It behaves the same way as <code>Any</code>, but appears implicitly, rather than through an explicit <code>Any</code> annotation:</p> <pre><code>from missing_module import MissingClass  # error: unresolved-import\n\nreveal_type(MissingClass)  # Unknown\n</code></pre> <p>ty also uses unions with <code>Unknown</code> to maintain the gradual guarantee, which helps avoid false positive errors in untyped code while still providing useful type information where possible.</p> <p>For example, consider the following untyped <code>Message</code> class (which could come from a third-party dependency that you have no control over). ty treats the <code>data</code> attribute as having type <code>Unknown | None</code>, since there is no type annotation that restricts it further. The <code>Unknown</code> in the union allows ty to avoid raising errors on the <code>msg.data = \u2026</code> assignment. On the other hand, the <code>None</code> in the union reflects the fact that <code>data</code> could possibly be <code>None</code>, and requires code that uses <code>msg.data</code> to handle that case explicitly.</p> <pre><code>class Message:\n    data = None\n\n    def __init__(self, title):\n        self.title = title\n\n\ndef receive(msg: Message):\n    reveal_type(msg.data)  # Unknown | None\n\n\nmsg = Message(\"Favorite color\")\nmsg.data = {\"color\": \"blue\"}\n</code></pre> <p>(Full example in the playground)</p>"},{"location":"reference/typing-faq/#why-does-ty-show-int-float-when-i-annotate-something-as-float","title":"Why does ty show <code>int | float</code> when I annotate something as <code>float</code>?","text":"<p>The Python typing specification includes a special rule for numeric types where an <code>int</code> can be used wherever a <code>float</code> is expected:</p> <pre><code>def circle_area(radius: float) -&gt; float:\n    return 3.14 * radius * radius\n\ncircle_area(2)      # OK: int is allowed where float is expected\n</code></pre> <p>This rule is a special case, since <code>int</code> is not actually a subclass of <code>float</code>. To support this, ty treats <code>float</code> annotations as meaning <code>int | float</code>. Unlike some other type checkers, ty makes this behavior explicit in type hints and error messages. For example, if you hover over the <code>radius</code> parameter, ty will show <code>int | float</code>.</p> <p>A similar rule applies to <code>complex</code>, which is treated as <code>int | float | complex</code>.</p> <p>Info</p> <p>These special rules for <code>float</code> and <code>complex</code> exist for a reason. In almost all cases, you probably want to accept both <code>int</code> and <code>float</code> when you annotate something as <code>float</code>. If you really need to accept only <code>float</code> and not <code>int</code>, you can use ty's <code>JustFloat</code> type. At the time of writing, this import needs to be guarded by a <code>TYPE_CHECKING</code> block:</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from ty_extensions import JustFloat\nelse:\n    JustFloat = float\n\ndef only_actual_floats_allowed(f: JustFloat) -&gt; None: ...\n\nonly_actual_floats_allowed(1.0)  # OK\nonly_actual_floats_allowed(1)    # error: invalid-argument-type\n</code></pre> <p>(Full example in the playground)</p> <p>If you need this for <code>complex</code>, you can use <code>ty_extensions.JustComplex</code> in a similar way.</p>"},{"location":"reference/typing-faq/#does-ty-have-a-strict-mode","title":"Does ty have a strict mode?","text":"<p>Not yet. A stricter inference mode is tracked in this issue. In the meantime, you can consider using Ruff's <code>flake8-annotations</code> rules to enforce more explicit type annotations in your code.</p>"},{"location":"reference/typing-faq/#why-cant-ty-resolve-my-imports","title":"Why can't ty resolve my imports?","text":"<p>Import resolution issues are often caused by a missing or incorrect environment configuration. When ty reports \"Cannot resolve imported module \u2026\", check the following:</p> <ol> <li> <p>Virtual environment: Make sure your virtual environment is discoverable. ty looks for an     active virtual environment via <code>VIRTUAL_ENV</code> or a <code>.venv</code> directory in your project root. See the     module discovery documentation for more details.</p> </li> <li> <p>Project structure: If your source code is not in the project root or <code>src/</code> directory,     configure <code>environment.root</code> in your <code>pyproject.toml</code>:</p> <pre><code>[tool.ty.environment]\nroot = [\"./app\"]\n</code></pre> </li> <li> <p>Third-party packages: Ensure dependencies are installed in your virtual environment. Run ty     with <code>-v</code> to see the search paths being used.</p> </li> <li> <p>Compiled extensions: ty requires <code>.py</code> or <code>.pyi</code> files for type information. If a package     contains only compiled extensions (<code>.so</code> or <code>.pyd</code> files), you'll need stub files (<code>.pyi</code>) for ty     to understand the types. See also this issue which     tracks improvements in this area.</p> </li> </ol>"},{"location":"reference/typing-faq/#does-ty-support-monorepos","title":"Does ty support monorepos?","text":"<p>ty can work with monorepos, but automatic discovery of nested projects is limited. By default, ty uses the current working directory or the <code>--project</code> option to determine the project root.</p> <p>For monorepos with multiple Python packages, you have a few options:</p> <ol> <li> <p>Run ty per-package: Run <code>ty check</code> from each package directory, or use <code>--project</code> to specify     the package:</p> <pre><code>ty check --project packages/package-a\nty check --project packages/package-b\n</code></pre> </li> <li> <p>Configure multiple source roots: Use <code>environment.root</code> to specify     multiple source directories:</p> <pre><code>[tool.ty.environment]\nroot = [\"packages/package-a\", \"packages/package-b\"]\n</code></pre> <p>This has the disadvantage of treating all packages as a single project, which may lead to cases in which ty thinks something is importable when it wouldn't be at runtime.</p> </li> </ol> <p>You can follow this issue to get updates on this topic.</p>"},{"location":"reference/typing-faq/#does-ty-support-pep-723-inline-metadata-scripts","title":"Does ty support PEP 723 inline-metadata scripts?","text":"<p>It depends on what you want to do. If you have a single inline-metadata script, you can type check it with ty by using uv's <code>--with-requirements</code> flag to install the dependencies specified in the script header:</p> <pre><code>uvx --with-requirements script.py ty check script.py\n</code></pre> <p>If you have multiple scripts in your workspace, ty does not yet recognize that they have different dependencies based on their inline metadata.</p> <p>You can follow this issue for updates.</p>"},{"location":"reference/typing-faq/#is-there-a-pre-commit-hook-for-ty","title":"Is there a pre-commit hook for ty?","text":"<p>Not yet. You can track progress in this issue, which also includes some suggested manual hooks you can use in the meantime.</p>"},{"location":"reference/typing-faq/#does-ty-support-mypy-plugins","title":"Does ty support (mypy) plugins?","text":"<p>No. ty does not have a plugin system and there is currently no plan to add one.</p> <p>We prefer extending the type system with well-specified features rather than relying on type-checker-specific plugins. That said, we are considering adding support for popular third-party libraries like pydantic, SQLAlchemy, attrs, or django directly into ty.</p>"}]}